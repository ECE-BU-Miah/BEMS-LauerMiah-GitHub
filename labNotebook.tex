%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Compact Laboratory Book
% LaTeX Template
% Version 1.0 (4/6/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Joan Queralt Gil (http://phobos.xtec.cat/jqueralt) using the labbook class by
% Frank Kuster (http://www.ctan.org/tex-archive/macros/latex/contrib/labbook/)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
% Important note:
% This template requires the labbook.cls file to be in the same directory as the
% .tex file. The labbook.cls file provides the necessary structure to create the
% lab book.
%
% The \lipsum[#] commands throughout this template generate dummy text
% to fill the template out. These commands should all be removed when 
% writing lab book content.
%
% HOW TO USE THIS TEMPLATE 
% Each day in the lab consists of three main things:
%
% 1. LABDAY: The first thing to put is the \labday{} command with a date in 
% curly brackets, this will make a new section showing that you are working
% on a new day.
%
% 2. EXPERIMENT/SUBEXPERIMENT: Next you need to specify what 
% experiment(s) and subexperiment(s) you are working on with a 
% \experiment{} and \subexperiment{} commands with the experiment 
% shorthand in the curly brackets. The experiment shorthand is defined in the 
% 'DEFINITION OF EXPERIMENTS' section below, this means you can 
% say \experiment{pcr} and the actual text written to the PDF will be what 
% you set the 'pcr' experiment to be. If the experiment is a one off, you can 
% just write it in the bracket without creating a shorthand. Note: if you don't 
% want to have an experiment, just leave this out and it won't be printed.
%
% 3. CONTENT: Following the experiment is the content, i.e. what progress 
% you made on the experiment that day.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------                               
%\UseRawInputEncoding
\documentclass[fontsize=11pt, % Document font size
                             paper=letter, % Document paper type
                             twoside, % Shifts odd pages to the left for easier reading when printed, can be changed to oneside
                             captions=tableheading,
                             index=totoc,
                             hyperref]{labbook}

%\documentclass[idxtotoc,hyperref,openany]{labbook} % 'openany' here removes the
   
\usepackage[bottom=10em]{geometry} % Reduces the whitespace at the bottom of the page so more text can fit

\usepackage[english]{babel} % English language
\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template

\usepackage[utf8]{inputenc} % Uses the utf8 input encoding
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs

\usepackage[osf]{mathpazo} % Palatino as the main font
\linespread{1.05}\selectfont % Palatino needs some extra spacing, here 5% extra
\usepackage[scaled=.88]{beramono} % Bera-Monospace
\usepackage[scaled=.86]{berasans} % Bera Sans-Serif

\usepackage{booktabs,array} % Packages for tables

\usepackage{amsmath} % For typesetting math
\usepackage{graphicx} % Required for including images
\usepackage{etoolbox}
\usepackage{float}
\usepackage[norule]{footmisc} % Removes the horizontal rule from footnotes
\usepackage{lastpage} % Counts the number of pages of the document

\usepackage[dvipsnames]{xcolor}  % Allows the definition of hex colors
\usepackage{fancyvrb}
\definecolor{titleblue}{rgb}{0.16,0.24,0.64} % Custom color for the title on the title page
\definecolor{linkcolor}{rgb}{0,0,0.42} % Custom color for links - dark blue at the moment

\addtokomafont{title}{\Huge\color{titleblue}} % Titles in custom blue color
\addtokomafont{chapter}{\color{OliveGreen}} % Lab dates in olive green
\addtokomafont{section}{\color{Sepia}} % Sections in sepia
\addtokomafont{pagehead}{\normalfont\sffamily\color{gray}} % Header text in gray and sans serif
\addtokomafont{caption}{\footnotesize\itshape} % Small italic font size for captions
\addtokomafont{captionlabel}{\upshape\bfseries} % Bold for caption labels
\addtokomafont{descriptionlabel}{\rmfamily}
\setcapwidth[r]{10cm} % Right align caption text
\setkomafont{footnote}{\sffamily} % Footnotes in sans serif

\deffootnote[4cm]{4cm}{1em}{\textsuperscript{\thefootnotemark}} % Indent footnotes to line up with text

\DeclareFixedFont{\textcap}{T1}{phv}{bx}{n}{1.5cm} % Font for main title: Helvetica 1.5 cm
\DeclareFixedFont{\textaut}{T1}{phv}{bx}{n}{0.8cm} % Font for author name: Helvetica 0.8 cm

\usepackage[nouppercase,headsepline]{scrpage2} % Provides headers and footers configuration
\pagestyle{scrheadings} % Print the headers and footers on all pages
\clearscrheadfoot % Clean old definitions if they exist

\automark[chapter]{chapter}
\ohead{\headmark} % Prints outer header

\setlength{\headheight}{25pt} % Makes the header take up a bit of extra space for aesthetics
\setheadsepline{.4pt} % Creates a thin rule under the header
\addtokomafont{headsepline}{\color{lightgray}} % Colors the rule under the header light gray

\ofoot[\normalfont\normalcolor{\thepage\ |\  \pageref{LastPage}}]{\normalfont\normalcolor{\thepage\ |\  \pageref{LastPage}}} % Creates an outer footer of: "current page | total pages"

% These lines make it so each new lab day directly follows the previous one i.e. does not start on a new page - comment them out to separate lab days on new pages
\makeatletter
\patchcmd{\addchap}{\if@openright\cleardoublepage\else\clearpage\fi}{\par}{}{}
\makeatother
\renewcommand*{\chapterpagestyle}{scrheadings}

% These lines make it so every figure and equation in the document is numbered consecutively rather than restarting at 1 for each lab day - comment them out to remove this behavior
\usepackage{chngcntr}
\counterwithout{figure}{labday}
\counterwithout{equation}{labday}

% Hyperlink configuration
\usepackage[
    pdfauthor={}, % Your name for the author field in the PDF
    pdftitle={Laboratory Journal}, % PDF title
    pdfsubject={}, % PDF subject
    bookmarksopen=true,
    linktocpage=true,
    urlcolor=linkcolor, % Color of URLs
    citecolor=linkcolor, % Color of citations
    linkcolor=linkcolor, % Color of links to other pages/figures
    backref=page,
    pdfpagelabels=true,
    plainpages=false,
    colorlinks=true, % Turn off all coloring by changing this to false
    bookmarks=true,
    pdfview=FitB]{hyperref}

\usepackage[stretch=10]{microtype} % Slightly tweak font spacing for aesthetics
%\setlength\parindent{0pt} % Uncomment to remove all indentation from paragraphs

%----------------------------------------------------------------------------------------
%	DEFINITION OF EXPERIMENTS
%----------------------------------------------------------------------------------------

% Template: \newexperiment{<abbrev>}[<short form>]{<long form>}
% <abbrev> is the reference to use later in the .tex file in \experiment{}, the <short form> is only used in the table of contents and running title - it is optional, <long form> is what is printed in the lab book itself

\newexperiment{example}[Example experiment]{This is an example experiment}
\newexperiment{example2}[Example experiment 2]{This is another example experiment}
\newexperiment{example3}[Example experiment 3]{This is yet another example experiment}

\newsubexperiment{subexp_example}[Example sub-experiment]{This is an example sub-experiment}
\newsubexperiment{subexp_example2}[Example sub-experiment 2]{This is another example sub-experiment}
\newsubexperiment{subexp_example3}[Example sub-experiment 3]{This is yet another example sub-experiment}

%----------------------------------------------------------------------------------------
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Command to make the lines in the title page

\setlength\parindent{0pt} % Removes all indentation from paragraphs

\begin{document}

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------
%\frontmatter % Use Roman numerals for page numbers

%\begin{center}

%

\title{
\begin{center}
\href{http://www.bradley.edu}{\includegraphics[height=0.5in]{figs/logoBU1-Print}}
\vskip10pt
\HRule \\[0.4cm]
{\Huge \bfseries Laboratory Notebook \\[0.5cm] \Large BEMOSS and Its Enhanced Applications}\\[0.4cm] % Degree
\HRule \\[1.5cm]
\end{center}
}
\author{\Huge Brian Lauer \\ \\ \LARGE blauer@mail.bradley.edu \\[2cm]} % Your name and email address
\date{Beginning March 13, 2018} % Beginning date
\maketitle

%\maketitle % Title page

\printindex
\tableofcontents % Table of contents
\newpage % Start lab look on a new page

\begin{addmargin}[0cm]{0cm} % Makes the text width much shorter for a compact look

\pagestyle{scrheadings} % Begin using headers

%----------------------------------------------------------------------------------------
%	LAB BOOK CONTENTS
%----------------------------------------------------------------------------------------
\labday{Monday, May 06, 2019}
I emailed Mr. Mattus asking him whether he made any progress on finding a laptop that
can be used to demonstrate the installation of BEMOSS. 
 
\labday{Thursday, May 09, 2019}
I picked up a department laptop from Mr. Mattus today. He cleared the partition
completely, so no time had to be spent removing a previous operating system from the
machine. Then, I installed Ubuntu 16.04.6 LTS on the system with a bootable USB flash
from the link provided on the BEMOSS installation guide.

\labday{Wednesday, May 22, 2019}
As recommended by Dr. Miah, I worked on running BEMOSS on the previous teamâ€™s laptop. By running \texttt{./startBEMOSS\_GUI.sh} inside the directory \texttt{/home/bemoss/BEMOSS3.5/GUI}, I was able to start up the BEMOSS Launcher Wizard. By selecting Run BEMOSS in the TKinter GUI the server was started,
and I was able to connect to the local web server at \texttt{localhost:8082.}. At this point, the software was able to detect the WeMo Insight Switch and thus control the Philips Hue bulb connected to it. I was not able to control the motor due to time constraints, but I will do so soon.
\medbreak\noindent
I did some more research on the features that BEMOSS offers at https://github.com/
bemoss/BEMOSS3.5/wiki/BEMOSS-Features including the ability to provide local and remote monitoring and security.

\labday{Thursday, May 23, 2019}

\labday{Friday, May 24, 2019}
The hierarchy of BEMOSS was researched today with the motivation of understanding
the software better in the Developer Resources. The first layer consists of the UI and User
Management which reside in the central server. Here admins can manage different nodes
on the network and either deny or accept requests from users. Layer 2 is the BEMOSS
Application and Data Management Layer which allows developers to create custom
applications for target devices that can be added to the UI. It may be interesting to explore
this feature once I have gotten a better idea of what sort of original contributions I would
like to make to the project. A motivation for this part of BEMOSS is to integrate web
services like IFTTT (IF This Then That) which may be interesting to use. The third layer is
the operating system and framework layer consisting of the agent platform VOLTTRON
developed by the Pacific Northwest National Laboratory. Six different agents perform
various different tasks such as detecting new devices (lighting/plug load controllers)
on the network and monitoring them to ensure they are running properly. Layer 4 is
the BEMOSS connectivity layer that handles the communication between the operating
system layer and the physical hardware devices. This is where support is extended
to different communication technologies like Wi-Fi, Ethernet, and Serial(RS-485). Each
device supported by BEMOSS has an API translator needed to handle the differences in
device attributes.

\labday{Monday, May 27, 2019}
No work was done due to Memorial Day.

\labday{Tuesday, May 28, 2019}
The outline for the presentation on May 31 follows:
\begin{itemize}
\item Introduction
\item Applications of BEMOSS
\item Hardware/software needed to install BEMOSS
\item Immediate future work
\end{itemize}

The following questions are answered to determine what needs to be added to the
presentation:

\begin{itemize}
\item What is BEMOSS? BEMOSS or Building Energy Management Open Source Software
is an agent-based software platform engineered to allow small- and medium-sized
commercial buildings to more seamlessly integrate equipment designed for sensing
and control. This software can allow building owners and engineers to manage
building energy use better by monitoring different load control devices such as
lighting loads, plug loads, and HVAC controllers.
\item How can BEMOSS be applied to the real world?
\item What hardware and software is needed to install BEMOSS?
\item What kind of future work is available to be implemented with this software?
\end{itemize}

After working on the presentation, I worked in the lab to document the toggling of
the WeMo insight switch with BEMOSS. Most of this information was gathered from
https://github.com/bemoss/BEMOSS3.5/wiki/User-Guide-for-BEMOSS-UI.
Once the BEMOSS server has started, type localhost:8082 in the web browser to go to
the BEMOSS Web UI. The username is â€™adminâ€™ and the password is the one set during
installation. To discover the switch, click the "Discover New Devices" tab in the left
navigation bar. Under the "All Plug Load Controllers" menu, select either "All Plug Load
Controllers" or "Belkin International Inc. Insight." Click "Discover Selected Devices" to
complete the process. The number of discovered devices will appear on the Discover
New Devices tab. If only one device has been discovered, a 1 will appear next to the
name Discover/Manage. On the Discover/Manage page, approve the device by setting the
approval status to "Approved" then select "Save Changes to Plugload Controllers." Navigate to the tab NODE$1$. Select "View All" under "Plugload", then select the WeMo smart plug icon to change the status of the plug and view the power consumption.  

\labday{Wednesday, May 29, 2019}
I spent the first few hours of the day reading through \cite{Pipattanasomporn2015}. I worked on researching the applications of BEMOSS and the introduction for the May 31st presentation. The future work still needs to be researched and added. Also, I would like to add some pictures to the slides to help the audience members gain a better visual understanding. Ideally, the presentation should be finished tomorrow morning, so I can have more time to practice. I practiced the presentation at the end of the day today without everything completed which isolated my knowledge gaps and gave me a better idea of what I should work on. To provide better flow between slides I must find ways to transition well between them. 

\labday{Thursday, May 30, 2019}
More work was done on the presentation.

\labday{Friday, May 31, 2019}
Work on presentation and meeting with other members of the Robotics and Mechatronics (RAM) group.

\labday{Monday, June 3, 2019}
I read through \cite{Zhang2016} and \cite{Khan2018} to obtain more ideas on original contributions I can make to the project. One thing I found in \cite{Khan2018} is the use of an induction motor in McNeese State University's microgrid. With a variable frequency drive, this could be integrated with BEMOSS to control different types of industrial loads. One problem is the high price tag on both. In \cite{Zhang2016}, a Particle Photon board was used to control the brightness of fluorescent lighting via step-dim ballasts. The Raspberry Pi is definitely a better option here than the Photon board as the previous senior project group used an RPi in their project. 

\labday{Tuesday, June 4, 2019}
Today, I attempted to install BEMOSS on my Ubuntu laptop. After running \texttt{./startBEMOSSGUI\_.sh} in the GUI directory, I encountered some problems. The following errors were thrown:
\begin{Verbatim}[tabsize=4]
Traceback (most recent call last):
	File "Web_Server/run/defaultDB.py", line 91, in <module>
		admin = User.objects.get(username='admin')
	File "/home/ramgroup/BEMOSS3.5/env/local/lib/python2.7/
	site-packages/django/db/models/manager.py", 
	line 85, in manager_method
		return getattr(self.get_queryset(), name)(*args, **kwargs)
	File "/home/ramgroup/BEMOSS3.5/env/local/lib/
	python2.7/site-packages/django/db/models/query.py", 
	line 379, in get
		self.model._meta.object._name
django.contrib.auth.models.DoesNotExist: User matching query does not exist.
OS settings imported
\end{Verbatim}

\begin{Verbatim}[tabsize=4]
Traceback (most recent call last):
	File "bemoss_lib/databases/cassandraAPI/initialize.py",line 186 in
<module>
		init()
	File "bemoss_lib/databases/cassandraAPI/initialize.py", line 99, in init
		casYamlFile = open(settings.PROJECT_DIR+"/cassandra/conf/cassandra.yaml",'r')
IOError: [Errno 2] No such file or directory: 
'/home/ramgroup/BEMOSS3.5/cassandra/conf/cassandra.yaml'
\end{Verbatim}

I was able to eliminate the first error by using 'admin' for the Django superuser rather than the default 'ramgroup'. I tried to eliminate the second error by deleting BEMOSS3.5 from my home directory and recloning; however, the same problem persisted. I found a directory named \texttt{~/BEMOSS3.5/cassandra} on the previous group's laptop which is not being created when I run BEMOSS on my machine. This directory contains the file "cassandra.yaml" which the file "initialize.py" is attempting to access. This leads me to believing that there is some issue with the creation of the directory.

\labday{Monday, June 10, 2019}
More work was done to install BEMOSS. I emailed one of the members of the previous senior project named Bob about the error.

\labday{Tuesday, June 11, 2019}
After looking through some of the files in \texttt{/BEMOSS3.5/GUI/GUI.py}, I found the line of code preventing the installation of BEMOSS which is 108:
\begin{verbatim}
bemoss_is_installed = os.path.isdir(ui_path) and os.path.isdir(cassandra_path) 
and os.path.isdir(env_path)
\end{verbatim}
Since the cassandra directory is non-existent, the expression \texttt{os.path.isdir(cassandra\_path)} evaluates as \texttt{False}.
\bigbreak\noindent
After some further searching I found that the BEMOSS is failing to download and install the cassandra database due to a dead link in the shell script
\begin{verbatim}
/BEMOSS3.5/GUI/bemoss_install_v3.5.sh
\end{verbatim} 
When line 48:
\begin{verbatim}
wget http://downloads.datastax.com/community/dsc-cassandra-3.0.9-bin.tar.gz
\end{verbatim} is run, a "404 not found" error is generated by the server. The URL was entered into a web browser and it was found that the requested URL was not found on the server.
\bigbreak\noindent
As a possible solution, I used a different URL to download the cassandra database in
\begin{verbatim}
/BEMOSS3.5/GUI/bemoss_install_v3.5.sh
\end{verbatim}
After adding a comment on line 48, the previously mentioned URL on line 49 is changed to
\begin{verbatim}
https://archive.apache.org/dist/cassandra/3.0.9/
apache-cassandra-3.0.9-bin.tar.gz
\end{verbatim}
Lines 49-53 were changed to
\begin{verbatim}
wget https://archive.apache.org/dist/cassandra/3.0.9/
apache-cassandra-3.0.9-bin.tar.gz
tar -xzf apache-cassandra-3.0.9-bin.tar.gz
sudo rm apache-cassandra-3.0.9-bin.tar.gz
sudo rm -rf cassandra/
sudo mv apache-cassandra-3.0.9 cassandra
\end{verbatim}  
After this, BEMOSS was successfully installed.
The post-installation instructions were followed on the BEMOSS wiki, but, at the end, errors were still being thrown while attempting to get the web server up and running.

\labday{Wednesday, June 12, 2019}
After viewing the issue on the BEMOSS repo:
\url{https://github.com/bemoss/BEMOSS3.5/issues/47}, I found that the IP address in \texttt{parent\_ip.txt} did not match the IP of my system, so I changed this to the correct IP. This corrected the problem and the BEMOSS web server was able to boot successfully. Note this text file is only created after BEMOSS is run.

\labday{Thursday, June 13, 2019}
In the lab, I worked on getting BEMOSS up and running. I mistakenly used the wired connection at first when attempting to run the BEMOSS server but decided to connect to the wireless network ECE-Robotics1 as the Raspberry Pi controlling the motor uses this network. I was able to login as admin into BEMOSS but experienced a problem when attempting to connect to the WeMo Insight switch. When I attempt to navigate to the plug load page to control the WeMo switch the page does not load. It is unclear whether this is an issue with the Insight switch or with BEMOSS itself. I also tried working with the WeMo plug on the previous group's Ubuntu laptop but ran into the same issue leading me to believe it is possibly an issue with the WeMo switch.

\labday{Friday, June 14, 2019}
More work was done at the beginning of the day to help identify and fix the problem of the Plugload page not loading. After one attempt the page eventually loaded but took a great deal of time. It was finally discovered that the laptop must be connected to the wired network as well as ECE-Robotics1 in order to function properly. Without a wired connection, the PC is unable to connect to the Internet which causes errors. However, although the software was working properly errors were reported by the TSDagent. These are captured in the figure below.
\bigbreak\noindent
\includegraphics[scale=0.5]{figs/screenshot61419.png}

I decided to try the same setup on the previous group's machine to see if I would receive the same problem. After running the software on the previous group's machine, I received the same errors with the TSDagent thus concluding that the proposed solution mentioned on page 31 is not a complete one. I will need to email Ashraf with the details on this. 
\bigbreak\noindent
In the meantime, I will attempt to get the DC motor running with the BEMOSS software. After modifying the file permissions of three of \texttt{shell\_control.sh} using
\begin{verbatim}
chmod u+x shell_control.sh
\end{verbatim}
I was able to identify and control the motor using \texttt{pyshell\_control.py} which rotates the motor counter clockwise then clockwise. Soon I need to start creating the GUI that will show all devices on the network and enable the ability to control them.

\labday{Monday, June 17, 2019}
Work on the presentation slides for June 21 was done. Further research on the Beamer class was conducted to add more detail to the presentation.

\labday{Tuesday, June 18, 2019}
The presentation slides are almost complete at this point. A few more captions need to be added to the figures and sources must be added to the bibliography.

\labday{Wednesday, June 19, 2019}
Work on the presentation was continued and uploaded to github. A few additions may need to be made as I was not able to get a full 10 minutes out of it. Tonight, the presentation will be practiced  and polished, so that I am ready to go by Friday. This time I need to know exactly what I am saying before going in so I can avoid any pauses.
\bigbreak\noindent
A page on wikipedia on computer networks was read:
\begin{verbatim}
https://en.wikipedia.org/wiki/Computer_network
\end{verbatim}
to better understand what is going on with this project. Knowledge of the python Tk interface must be obtained to build the GUI due June 21.


\labday{Thursday, June 20, 2019}
Had a short meeting with Dr. Miah in the lab. Here is what needs to be done:
\begin{itemize}
\item Add progress and plan to presentation.
\item IoT discovery and control GUI and BEMOSS plugload icon must be implemented before June 28. Conference paper must be completed and submitted before June 28. However, this is not likely to be finished by then as little to no progress has been made on the GUI or BEMOSS motor integration.
\item Need to start recording hours when working with the DC motor so I can get paid. I need to talk with Mrs. Polen to get an account setup with Bradley. 
\item I need to start thinking of a device to implement in BEMOSS. Otherwise, this project will not be successful without an original contribution. Thus, a lot of research must be done.
\item Agent-based architecture will need to be researched by reading some research papers.
\item Need to send Ashraf an email asking if he has made any progress on the project.
\bigbreak\noindent
All the scripts written by Reece and Bob to control the motor were understood except for \texttt{XBEETEST.py} on the Raspberry Pi as I still need to do research on the XBee modules if I am to use them in the project.
\end{itemize}

\labday{Friday, June 21, 2019}
To better understand how to create the GUI to control the devices in the lab, I read up on the documentation for PyGTK at \url{https://python-gtk-3-tutorial.readthedocs.io/en/latest/layout.html#}. 

\labday{Sunday, June 23, 2019}
Work was done on researching a device to integrate within BEMOSS. Here are some possible ideas:
\begin{itemize}
\item Ultrasonic Range Finding module - hcsr$04$\\
I have one of these and have been programming it some and could potentially have an interesting application for IoT. However, this does seem rather simple and would not likely take long to fully implement.
\item Digital Multimeter
\item Accelerometer
\item Gyroscope
\item Dust Sensor \url{https://www.waveshare.com/dust-sensor.htm}
\item PM2.5 Particle Sensor \url{https://www.cytron.io/p-honeywell-pm2.5-particle-sensor-module} Looking at this module it uses a two wire UART output so it would likely be very easy to interface with the Raspberry Pi 
\end{itemize}

\labday{Monday, June 24, 2019}
While building the GUI, I came to realize that Gtk is simply too complex for me, so I decided to change tkinter which is a bit simpler. At this point I have finished the GUI and simply need to connect the callbacks to the events using tk.widget.bind(event,callback). Once this has been done I will be ready to move on to implementing the logic to control the wemo switch and motor within the tkinter application.

\labday{Tuesday, June 25, 2019}
To better understand lower level networking concepts, I will use the python module \texttt{socket} to ping addresses on the network and resolve their hostnames. It may save time to use the \texttt{nmap} command used by the previous group; however, I would like to build a system from scratch completely in python. As the motor needs to be implemented within BEMOSS as soon as possible, I will work on this first and determine how to use the wemo switch later. I will base some of my work off \cite{scanopy}. However, after working for some time I found that the program I was attempting to write was rather inefficient and using the nmap command will be much more faster. Thus I have decided to use the scripts written by Bob and Reece. I was able to write a single python script using the socket module to parse through all hosts on the network 'ECE-Robotics$1$' and place them in a list along with their respective IP addresses.

\labday{Wednesday, June 26, 2019}
I was able to succesfully add the Raspberry Pi and Wemo switch names to the listbox; however if the button 'Discover IoT Devices' is pressed continually, devices will continually be added to the list. Right now I need to determine how to initialize the Raspberry Pi by sshing into it. Then, after selecting the toogle button, I must figure out how to remotely send commands to the device to turn it on or off without having to reconnect. After some tinkering I found that I can simply just ssh into the pi and run a script that simply turns the moltor on when the button is toggled on and off when the button is toggled off. Thus no initializatin will be needed. 
\bigbreak\noindent
I need to write scripts to perform the following operations:
\begin{itemize}
\item Use nmap to the scan wifi credentials
\item Place the credentials into text file
\item Scan for the IP addresses and place them into a text file
\item Assign the address read from the file to a variable and use this to remotely login to the device (for the RPi)
\end{itemize}
However, I have almost no knowledge of bash so this will take some researching. I found a way of storing the first IP address in \texttt{IPAddresses.txt} in a variable that can be used to call the python scripts running on the pi to control the motor. Each time the toggle button is pressed, the text file is read from which is inefficient. More ideally I would like to implement some feature where the IP addresses of the devices are stored in a place that can be accessible to any shell script within the directory. I would like to do this later on; however, I need to move on to working the Wemo switch's API into this application.
\bigbreak\noindent
To perform the implementation of the WeMo switch, I will need to read through the documentation provided by the BEMOSS team and some of the python code to find exactly what code needs to be written to create a fully functional system. This code is very complicated thus it may take a great deal of time to work through.
\bigbreak\noindent
I found a url on the bemoss website: \url{www.bemoss.org/api-interface-wemo-smart-plug/} that explains how some of the code works. The switch uses the upnp (Universal Plug and Play) protocol. 

\labday{Thursday, June 27, 2019}
A github gist was located that contains a script to control a wemo device: \url{https://gist.github.com/pruppert/af7d38cb7b7ca75584ef}. I was able to successfully control the wemo switch with this. This will be helpful in understanding the code provided in the bemoss repo and on the bemoss website. The url to send commands to the switch is

\begin{verbatim}
http://192.168.1.112:49153/upnp/control/basicevent1
\end{verbatim}
I attempted to add this url into the method \texttt{getDeviceStatus}; however when I run the code I receive a 500 response (internal server error). After running an nmap scan with the port scan enabled I found that the wemo switch uses both ports 53 and 49153 for communication, so the cause of the problem here is unknown. Later, I determined the problem is that no XML was being sent in the body of the POST request to the device. I simply copied the XML from the python script I found online to control the switch and modified the code from the bemoss website. This is the function used to turn on the Insight switch.
\begin{Verbatim}[tabsize=4]
def turnOnSwitch():
	header = {
		'Content-Type': 'text/xml; charset="utf-8"',
		'SOAPACTION': '"urn:Belkin:service:basicevent:1#SetBinaryState"'
	}
	body='<?xml version="1.0" encoding="utf-8"?>
<s:Envelope xmlns:s="http://schemas.xmlsoap.org/soap/envelope/" 
s:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">
<s:Body><u:SetBinaryState xmlns:u="urn:Belkin:service:basicevent:1">
<BinaryState>1</BinaryState>
</u:SetBinaryState></s:Body></s:Envelope>'
	controlUrl='http://192.168.1.112:49153/upnp/control/basicevent1'
	response = requests.post(controlUrl, body, headers=header)
	del response																																										
\end{Verbatim}
To understand how this code works more research will need to be done as I know very little about XML.

\labday{Friday, June 28, 2019}
Layer 1 (UI layer) of the BEMOSS hierarchy was researched for a few hours to try and understand how new devices are to be added to BEMOSS. Details such as how the 	Model-Message-View-Template works and the UI project structure are provided. However, this doesn't really provide any details on what happens when an element in the UI is selected such as pressing a button to toggle a device on and how the message flows down to the device. In other words, I'm not able to understand the chain between the UI layer and the device as this is not documented on the BEMOSS wiki. A single file I found that could be possibly helpful is \texttt{~/BEMOSS3.5/Web\_Server/webapps/device/templates/plugload/plugload.html}. This will require some digging to understand the html, css, and jQuery as I have little to no experience in any of these. In addition, I may need to research the agent based system to understand how these agents interact with the devices' APIs.   

\labday{Monday, July 1, 2019}
To understand how the device discovery agent works, I studied each line of 
\begin{verbatim}
BEMOSS3.5/Agents/DeviceDiscoveryAgent/devicediscovery/agent.py
\end{verbatim}
carefully. In \texttt{BEMOSS3.5/BEMOSS\_lib/db\_helper.py} a class named 
% Note using underscore by itself will throw an error as it is normally used to typeset underscores in math mode. 
db\_connection is defined with method database\_connect that reads the system's ip address from \texttt{parent\_ip.txt} and passes it as an argument into the method psycopg2.connect in order to connect to the PostgreSQL database named 'bemossdb'. Other keyword arguments that must be passed include port number, database name, user name, and database password. The full method call is
\begin{verbatim}
con = psycopg2.connect(host='136.176.122.127',port='5432',database='bemossdb', user='admin',password='admin')
\end{verbatim}

\labday{Tuesday, July 2, 2019}
Today, I copied the file \texttt{API\_WeMoPlugload.py} and renamed the copy to \texttt{API\_rpi.py} in the directory \texttt{BEMOSS3.5/DeviceAPI}. However, this did not result in a new device named RPI appearing in the "Discover New Devices" page on the BEMOSS dashboard. Thus, I must do further research to determine where these names are added to the dashboard. After using the command \texttt{grep -r 'All Plug Load Controllers' .} in the directory $\sim$\texttt{/BEMOSS3.5} I was able to determine which html file places the vendor name and device model on the "Discover New Devices" page. This file is
\begin{verbatim}
/BEMOSS3.5/Web_Server/webapps/
discovery/templates/discovery/manual_discovery.html
\end{verbatim}
After changing the values of \texttt{'vendor\_name'} and \texttt{'api\_name'}in the dictionary returned by the method \texttt{API\_info}, the rpi was still not appearing in the device discovery page. An error was encountered as the values corresponding to the key \texttt{vendor\_name} in the copied python script \texttt{API\_API\_WeMoPlugloadtest}were the same as the values in the original API script \texttt{API\_WeMoPlugload}. Thus it is impossible to have two devices with different vendor names and the same device model.

\labday{Wednesday, July 3, 2019}
After receiving a message from Dr. Miah, the current goal is to find a way to add a new copy of the plugload interface into the same directory as the current one and change the variables \texttt{vendor\_name} and \texttt{device\_model}. Following the meeting with Dr. Miah, I realized that I must work to fully understand the BEMOSS interface and the wemo switch otherwise I will not be able implement a new device successfully. This must be done by understanding the source code. I started reading through the device discovery agent source code line by line to fully understand it.  

\labday{Thursday, July 4, 2019}
After making some comments in the \texttt{agent.py} file, indentation errors appeared while launching the server, the decision was made to reclone the BEMOSS repo. Progress must be made quickly today to understand the code and complete the clone of the plugload interface. I found a try ... except statement on lines 307 to 314 of \texttt{agent.py} that prevent the device from being detected. In a nutshell, the agent queries the PostgreSQL database with the query \texttt{SELECT * from supported\_devices where vendor\_name = 'Belkin International Inc.' and device\_model = 'Insight'} when querying the Insight. If no row in the table is found, then it is determined that the device is not supported by BEMOSS.
\bigbreak\noindent
I attempted to place a copy of the file \texttt{API\_WeMoPlugload.py} in a separate directory named \texttt{research}; however, when running the file \texttt{platfrom\_initiator.py} the database prevents a device with a duplicate key from being added.  

\labday{Friday, July 5, 2019}
Several attempts to restart the server in the lab were made by recloning the repo as many errors were encountered causing the server to not startup.

\labday{Monday, July 8, 2019}
I was able to detect a new device with the copy of the wemo plug api in the second folder I made. On the device discovery page, the device name and model were the ones I declared in the \texttt{API\_WeMocopy.py} file. Once the device was discovered, the vendor name and model did not match what I provided in the previously mentioned file. Plug and play discovery is never completed due to this error reported by the device discovery agent:
\begin{verbatim}
IntegrityError: duplicate key
value violates unique constraint
"device_info_pkey"\nDETAIL:  
Key (agent_id)=(Insi_231707K120123A) already exists.\n\n')
\end{verbatim}
I restarted BEMOSS to see if this was an issue due to the fact that the device had not been deleted from the device info table. Since significant alterations to the source code will likely be necessary, it was decided that the focus will now be placed on the dc motor interface now which is due July 31, 2019.
\bigbreak\noindent
The first step I took in understanding how to add the device to the software is hardcoding a dictionary with ip address, mac address, device model (raspberrypi's username), and vendor name (Raspberry Pi Foundation). I defined these variables in a method named discover in the class API inside the module \texttt{API\_PittmanMotor}. In the near future, an automated plug and play discovery process will need to be implemented but for now I would like to simply hardcode the parameters. Since I am a little lost on how the web framework used to build the platform (Django) works, I decided to watch a tutorial on it and do further research.
\bigbreak\noindent
Django is an open source web framework. It is based on the model, view, template architecture system as explained below.
\begin{enumerate}
\item Model: Interact with and validate python data
\item Template: Presentation layer (html files)
\item View: Decides which template to display by interacting with the model
\end{enumerate}
Project uses multiple apps to define the functionality of the site.

\labday{Tuesday, July 9, 2019}
I postponed increasing knowledge as the more important task at the moment is understanding the API translator methods such as \texttt{setDeviceStatus}, \texttt{getDataFromDevice}. After starting up BEMOSS without any code to the body of the previously mentioned functions the device was able to be succesfully discovered, but the navigation bar disappeared when setting the device status to approved in the UI. Thus more configuration will be necessary to create a system that perfectly emulates the plugload interface.
\bigbreak\noindent
As a test I ran the file \texttt{DeviceAPI/BaseAPI\_WeMo.py} in a virtual environment to toggle the wemo switch. After commenting out a couple of method calls in the main function I was able to succesfully toggle the device. This should be a good way of testing the raspberry pi without having to start BEMOSS everytime.
\bigbreak\noindent
Something I found on the developer resources is that the Device Agent is responsible for handling most of the communication with the UI. It will likely beneficial for me to read over this source code. The method \texttt{agent\_setup} contains a decorator that registers the method to the callback 'onsetup' which is an event triggered at one of the agents' stages of life. Inside this method, three method calls generate callbacks to methods defined inside the BasicAgent class which are \texttt{updateUIBehavior}, \texttt{deviceIdentifyBehavior}, and \texttt{deviceControlBehavior}.
\bigbreak\noindent
I added code to \texttt{setDeviceStatus} in the file \texttt{API\_RaspberryPi.py} to ssh into the raspberry pi and run python scripts depending if the device status is set to "ON" or "OFF". Once I started up BEMOSS though I ran into some problems as had not defined the method \texttt{getDataFromDevice}. This must return a dictionary otherwise errors will arise when displaying the data on the dashboard.

\labday{Wednesday, July 10, 2019}
The problem involving the side navigation bar not being rendered was not a result of no dictionary being returned from \texttt{getDataFromDevice}. I found that each group of the mac address must not be separated by colons; rather no delimiter is to be used at all. Once I removed the colons from the MAC address in the API file, I was able to succesfully control the Raspberry Pi at my house. I wrote scripts that are able to turn on and off an led connected to one of the GPIO pins on my RPi. In the lab, it should be fairly simple to run the scripts on the RPi in the lab \texttt{XBEEON.py} and \texttt{XBEEOFF.py} to send commands to the motor in place of the scripts I use to control the LED. 
\bigbreak\noindent
A second problem still exists stemming from a KeyError exception in the file 

\texttt{Web\_Server/webapps/dashboard/templatetags/device\_count\_in\_zone.py}. I get the error \texttt{Cannot access the value, returning default: '0'} which is printed in the function \texttt{get\_value\_with\_default} when the dictionary does not contain one of the keys passed as an argument into the function. This is shown in the screen capture below.
\includegraphics[scale=0.5]{figs/orderedDictError.png} 
\bigbreak\noindent
In the lab, I was able to successfully control the motor with the plugload interface by making changes to the file \texttt{API\_RaspberryPi.py}. More work was done to correct the error.

\labday{Thursday, July 11, 2019}
To test whether the new API script I wrote was the cause of the problem, I moved the file \texttt{API\_RaspberryPi.py} to the home directory and restarted BEMOSS. The message \texttt{Cannot access the value, returning default: 0} was still printed to the server log at startup, so the only thing I can conclude is that this is not an issue with the new API file. As another test, I will install BEMOSS in another directory. The same messages were printed to the log when attempting to the get the number of devices on the network, so at this point the messages will be ignored.
\bigbreak\noindent
As a first step in automating the discovery process, I added the line to the method discover in \texttt{API\_RaspberryPi.py}
\begin{verbatim}
nmap = subprocess.check_output('sudo nmap -sn 192.168.1.0/24',shell=True)
\end{verbatim}
When this line is run, a \texttt{CalledProcessError} is thrown which remove nmaps as an option that can be used to detect device information. The command was attempted to be run without superuser priviliges; however, raw IP packets are needed to resolve MAC addresses and manufacturer names with nmap.

\labday{Friday, July 12, 2019}
I completed writing the discover method for the Raspberry Pi API today. A file named \texttt{ownerinfo.json} was added to the research directory where the mac address of the Raspberry Pi used to control the motor can be added. This makes identifying the correct Raspberry Pi easier as it is possible that more than one Pi could be on the network at the same time. The command nmap was used to ping all machines on subnet 255.255.255.0. After this has been done information is stored in the machine's cache so that the address resolution protocol (arp command) may be used to find the mac addresses corresponsding to the ip address on the network. After this, it is determined whether the pi's mac addresses is located in the output of the \texttt{arp -a} command.
\bigbreak\noindent
I need to research DNS python packages to find the username of Raspberry Pi. Also, methods for storing the Raspberry Pi's password securely in the BEMOSS database must be researched.

\labday{Monday, July 16, 2019}
After doing some research I decided that I will be attempting to discover the Raspberry Pi with SSDP (Simple Service Discovery Protocol) rather than using the \texttt{nmap} and \texttt{arp} commands. Research will need to be done on these two protolocols to be able to understand how to discover and control the RPi.
\bigbreak\noindent
UPnP or Universal Plug and Play consists of three different protocols which are 
\begin{itemize}
\item SSDP (Simple Service Discovery Protocol) for finding devices on the network
\item SCPD (Service Control Point Definition) defines the actions provided 	
\item SOAP (Simple Object Access Protocol) calls actions
\end{itemize}
I found after further research that UPnP is simply not going to work with raspberry pi as it is more designed for home media servers and not suited for my specific application which is running commands on the Pi.

\labday{Tuesday, July 16, 2019}
I attempted to run the command \texttt{sudo nmap -sn 192.168.1.0/24} in the discover method; however, I was not able to login in the volttron log terminal although the prompt for the password did appear. I attempted to launch the terminal as superuser by running the command to launch the terminal in the \texttt{GUI.py} as superuser. However, I ran into several issues involving priviliges although I did remove the sudo prefix from the command. Now I will reinstall BEMOSS.
\bigbreak\noindent
Rather than using both the nmap and arp commands together I made the decision to running the nmap command as superuser to resolve the manufacturer names and MAC addresses. I ran into a problem when using \texttt{subprocess.call('sudo nmap -sn 192.168.1.0/24')} as the terminal does not allow any text to be passed to stdin while the agents are running. In addition, execution of the function will continue even though system password is provided. In the end I decided to revert back to the original code as the motivation for running nmap as super user is to retrieve the mac and IP addresses.
\bigbreak\noindent
Lastly, I found that the Raspberry Pi contains an option named Remote GPIO in the Raspi-Config which will enable the GPIO pins to be controlled over the network. No login is required to access the pins on this server only the IP address. This will hopefully streamlines tasks involving the gpio pins greatly.

\labday{Wednesday, July 17, 2019}
Following work on my presentation, I discussed with Dr. Miah using the Remote GPIO which was agreed upon. However, for the next presentation I would like to have a fully functional interface using the current method. This will require me to encrypt both the username and password of the Raspberry Pi and store in the json file that the raspberry pi API file accesses. Thus some research will need to be done on how to perform this encryption. Later (next week) I would like to get the remote GPIO interface working and implemented. Some problems still exist with this method such as security as multiple different machine may be able to control the GPIO pins at once. Also, the XBee library that is used to control the xbee modules might not be compatible with the latter method. I know very little of how zigbee communication works or how the modules work, so this will require much research.
\bigbreak\noindent
I encrypted both the username and password of the raspberry pi by using the function \texttt{encrypt\_value} in the module \texttt{bemoss\_lib.utils.encrypt} and placed both these encrypted strings in the json file. I found that I needed to decrypt the values when formatting the string used to ssh into the pi. After finding that only the password must be encrypted, I replaced the username in the json file with the plain text version.

\labday{Thursday, July 18, 2019}
Today, I found that I have not implemented the method \texttt{identifyDevice} in the Raspberry Pi API. It is to be implemented as follows:
\begin{itemize}
\item At start, \texttt{identifyDeviceResult = False}
\item Keep the current state of one of the changeable device variables (in this case the status)
\item Change device variable that is visually noticeable
\item Delay for 5 seconds
\item Change device variable back to previous state
\item if successful, \texttt{identifyDeviceResult = True}
\end{itemize}
After looking through some of the Philips Hue API code, I found that the method \texttt{get\_variable} is used to check whether the device is on or off rather than directly communicating with the device through the method \texttt{getDataFromDevice} like in the WeMo plugload API. As a test I will print \texttt{get\_variable('status')}in the method \texttt{identifyDevice} in the Raspberry Pi API to check whether this key value pair is in the dictionary defined in the BaseAPI's constructor. As of now, I do not know of a way of checking the status of the motor from the RPi using the GPIO pins and XBEE modules, so using the method from the Philips Hue API would be ideal.
\bigbreak\noindent
After pressing the button \texttt{Identify Device} in the list of plugload controllers, the message logged to the console is always \texttt{'ON'}. The reason for this is likely the code I wrote in the method \texttt{getDataFromDevice} which is shown below:
\begin{Verbatim}[tabsize=4]
def getDataFromDevice(self):
	# TODO 
	devicedata = dict()
	devicedata['status'] = BEMOSS_ONTOLOGY.STATUS.POSSIBLE_VALUES.ON 
	# setting the value to "ON"
	return devicedata
\end{Verbatim}
The statement \texttt{BEMOSS\_ONTOLOGY.STATUS.POSSIBLE\_VALUES.ON = 'ON'} is defined in the file \texttt{BEMOSS\_ONTOLOGY}. From the BEMOSS developer resources for layer 4 of the BEMOSS hierarchy I found:\\

"Out of all the above methods, the getDataFromDevice method can be periodic. This means
it can query and receive device data periodically. This ensures that the data are updated."\\

In the Basic Agent source code, a method name \texttt{deviceMonitorBehavior} is called periodically which calls \texttt{getDeviceStatus}. A call to \texttt{getDataFromDevice} occurs here which returns a dictionary and calls \texttt{convertDeviceStatus} to update the \texttt{variables} dictionary which is declared by the \texttt{BaseAPI}. Thus I must find a way to directly query the Raspberry Pi for the motor status. To start the pin mappings are between the RPi and XBee s2c module are listed below:

\begin{center}
\begin{tabular}{|c|c|}
\hline
Raspberry Pi & XBee S$2$C\\
\hline
$6$ (GND) & VSS\\
$8$ (TXD) & DIN\\
$10$ (RXD) & DOUT\\
$17$ ($3$V$3$) & VCC\\
\hline
\end{tabular}
\end{center}

\labday{Friday, July 19, 2019}
In the afternoon session with the members of ram group, I experimented with the AT commands used to control the remote XBee connected to the L$298$N H-Bridge driver. The pin mappings are shown in the table below:
\bigbreak
\begin{center}
\begin{tabular}{|c|c|}
\hline
XBee & L$298$N\\
\hline
IO$3$ & I$2$\\
\hline
IO$4$ & I$1$\\
\hline
\end{tabular}
\end{center}
\bigbreak
Also, from the L$298$N datasheet this table lists the DC motor control A pins and how the output of the h-bridge is effected:
\bigbreak
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
EA & I$1$ & I$2$ & Motor A status\\
\hline
$0$ & $0$ & $1$ & Clockwise rotation\\
\hline
$0$ & $1$ & $0$ & Anticlockwise rotation\\
\hline
\end{tabular}
\end{center}
\bigbreak
As a side note, the EA port is used for PWM.
\bigbreak
However, the shaft rotations are swapped when using the motor in the lab.

\labday{Monday, July 22, 2019}
One of the AT commands use to read the digital IO of the XBee modules is the IC (Digital Change Detection) command. The command can "set or read the digital I/O pins to monitor  for changes in the I/O state." When the DIO state changes, a sample can be sent immediately to the coordinator XBee from the remote XBee. However, this does not send any information on the state of the pin. The command IS "forces a read of all enabled digital and analog input lines." Of course, here a wire will be need to be connected between the output pin (IO$3$ or IO$4$) and another pin configured as a digital input. When the device needs to be queried for the status of the digital IO pins, the command IS will be sent to the remote XBee. Then using the method \texttt{XBee.wait\_read\_frame} I can read the data received on the UART connection from the remote XBee. Tomorrow, in the lab this will need to be experimented with.

\labday{Tuesday, July 23, 2019}
I tried using the commands mentioned in yesterday's lab notebook to no avail. This is the code I wrote to try to receive data sent from the remote XBee:
\begin{Verbatim}[tabsize=4]
from xbee import XBee
import serial
import time

ser = serial.Serial('/dev/ttyS0',9600)
xbee = XBee(ser)

xbee.remote_at(
		dest_addr=b'\xff\xff'
		command='D3'
		parameter=b'\x04')
xbee.remote_at(
		dest_addr=b'\xff\xff'
		command='IS'
		parameter=b'\x03')
while True:
	try:
		print(xbee.wait_read_frame())
	except KeyboardInterrupt:
		break
\end{Verbatim}
The XCTU software was downloaded to work on configuring the remote MotorDriver XBee. IR, sample rate, was set to 1000 ms or a hex value of 0x3e8 and D1, dio1, was set as a digital input. Running \texttt{ser.read()} results in an output of \texttt{'\textbackslash x00'}. Thus, no data is being received even though data should be sent to coordinator at a rate of 1 second.

\labday{Wednesday, July 24, 2019}
I decided to try experimenting with the digi-xbee python library. After following the instructions to configure the devices at 

\url{https://xbplib.readthedocs.io/en/latest/getting_started_with_xbee_python_library.html#gsginstall},
I was unable to send AT commands to the end point XBee to toggle the motor. This was later resolved after setting the output values of IO$3$ and IO$4$ to opposite values using XCTU. Later I was able to read the digital values of these IO lines (whether they are high or low). This means that only two IO lines will be needed to control the remote XBee module rather than 4 as the status of the IO line can be read directly even if it is a digial output. A script was written named \texttt{XBEEcontrol.py} that can toggle the motor and determine the status of the enabled pins on the remote XBEE. At the end of the day I was able to successfully identify the motor by toggling it twice with a 5 second pause inbetween. The last part of the implementation is adding the motor images to the frontend.

\labday{Thursday, July 25, 2019}
I found an picture of the GM$8000$ series motor and added images denoting when the motor is on and off to the \texttt{Web\_Server/static/images} directory after removing the default background with GIMP.
\bigbreak\noindent
The next task is working on adding a new device type to BEMOSS called 'Motor'. In the file \texttt{Web\_Server/run/defaultDB.py}, I added the lines
\begin{verbatim}
dt5 = DeviceType(id=5, device_type='Motor')
dt5.save()
\end{verbatim}

\labday{Friday, July 26, 2019}
Starting BEMOSS with changing the lines from yesterday result in an error when attempting to add the Raspberry Pi API to the list of the supported devices. After running the file \texttt{BEMOSS3.5/Web\_Server/run/defaultDB.py} by typing \texttt{python Web\_Server/run/defaultDB.py} in the \texttt{BEMOSS3.5} directory the problem was fixed. BEMOSS was started successfully; however, the widget listing Motors was not available on the 'Discover New Devices' page. In the file \texttt{Web\_Server/webapps/discovery/views.py}, on line 58, \texttt{power\_meters} was changed to motors and on line 71, the key value pair for the power\_meters in the \texttt{devices} dictionary was removed and a key value pair for motor was added. After making further changes to the javascript and html manual discovery files, the issue was not corrected. It was later found that a closing div tag was missing from the file to close the div with class "row". Another exception was thrown when trying to access the pass usage statistics.

\labday{Monday, July 29, 2019}
The following error was thrown when running the \texttt{platform\_initiator.py} file when attempting to add the motor API to the database.
\begin{verbatim}
insert or update on table "supported_devices" 
violates foreign key constraint
"supported_devices_device_type_id_1f8832cb_fk_device_type_id"
DETAIL:  Key (device_type_id)=(5) is not present 
in table "device_type".
\end{verbatim}
This error is fixed by running the file \texttt{Web\_Server/run/defaultDB.py} which will update the BEMOSS database. Next to help clear up the VOLTTRON log file I attempted to dissect the error message reported by the Time Series Database Agent. This error is presented below
\begin{Verbatim}[tabsize=4]
Traceback (most recent call last):
	File "/usr/lib/python2.7/logging/__init__.py", line 861, in emit
		msg = self.format(record)
	File "/usr/lib/python2.7/logging/__init__.py", line 734, in format
		return fmt.format(record)
	File "/home/ramgroup/BEMOSS3.5/volttron/platform/agent/utils.py", line 242, in format
		return jsonapi.dumps(dct)
	File "/home/ramgroup/BEMOSS3.5/env/local/lib/python2.7/
	site-packages/zmq/utils/jsonapi.py", line 40, in dumps
		s = jsonmod.dumps(o, **kwargs)
	File "/home/ramgroup/BEMOSS3.5/env/local/lib/python2.7/
	site-packages/simplejson/__init__.py", line 399, in dumps
		**kw).encode(obj)
	File "/home/ramgroup/BEMOSS3.5/env/local/lib/python2.7/
	site-packages/simplejson/encoder.py", line 296, in encode
		chunk = self.iterencode(o, _one_shot=True)
	File "/home/ramgroup/BEMOSS3.5/env/local/lib/python2.7/
	site-packages/simplejson/encoder.py", line 378, in iterencode
		return _iterencode(o, 0)
	File "/home/ramgroup/BEMOSS3.5/env/local/lib/python2.7/
	site-packages/simplejson/encoder.py", line 273, in default
		o.__class__.__name__)
TypeError: Object of type DefaultEndPoint is not JSON serializable
Logged from file connection.py, line 1100
\end{Verbatim}
A logging issue is obviously present here and these stack traces are printed via logging message. Logging messages can have different levels of severity. In increasing order they are:
\begin{itemize}
\item DEBUG: Detailed information, typically of interest only when diagnosing problems.
\item INFO: Confirmation that things are working as expected.
\item WARNING: An indication that something unexpected happened, or indicative of some problem in the near future (e.g. â€˜disk space lowâ€™). The software is still working as expected.
\item ERROR: Due to a more serious problem, the software has not been able to perform some function.
\item CRITICAL: A serious error, indicating that the program itself may be unable to continue running.
\end{itemize}
The error above has level ERROR so the TSD Agent is not able to perform some function.
\bigbreak\noindent
It appears as if some objects cannot serialized by the python json module after some investigation. A possible fix to this problem is removing all the debug logging statements from the files in the cassandra python driver. However, this would take a great deal of time as there are many of them. Also, these logging statements are likely needed in case another problem arises. As mentioned from the log statements, on line \texttt{1100} of \texttt{cassandra.connection.py}, the following debug log statement exists:
\begin{verbatim}
log.debug("Sending options message heartbeat on idle connection (%s) %s",
                 id(connection), connection.endpoint)
\end{verbatim}

\labday{Tuesday, July 30, 2019}
In the lab, I found that the verision of the Datastax python driver used by the previous senior project group is different and only logs host names to the file rather than objects of classes defined inside the connection file. Today, I will meet with Dr. Miah to work on resolving this issue. While working on testing the motor interface I found that the power supply is not working properly. It fails to turn on immediately when the \texttt{XBEEcontrol.py} script is run with the argument \texttt{turnOnMotor}. A potential cause is the lack of a flyback diode across the input terminals to the motor which could be damaging the power supply due to voltage spikes.

In the meantime, before the meeting, I will work on trying to add plugload chart onto the motor page. Even though I am able to control the motor with the switch and identify device button, none of the data is added to the database. Something to note is that each table in BEMOSS is named according to the \texttt{agent\_id}. Somewhere in the repository these tables are added to the database; however, it is unclear where that occurs. According to the BEMOSS-Data-Management section of the developer resources: "During operation, the device agents connect to the Cassandra node on the same machine the agent is running, using Cassandra python driver, and writes time series data to a unique table named after the device\_id it is controlling."

After the meeting with Dr. Miah, it was determined that the current bug involving the cassandra python driver is a top priority. No paper will be submitted if this current issue still exists. A print statement was added on lines $133$ and $139$ of the TSDAgent source code: \texttt{print(message)}. One of the messages logged to the \texttt{volttron.log} file is 
\begin{verbatim}
{u'tablename': u'platform_event', u'all_vars': 
{u'event_id': u'155df44e-e45b-4271-bc44-ce053509d22a', u'start_time': 
u'2019-07-31 04:37:42:936113*None', u'date_id': u'2019-07-30', u'agent_id': 
u'platformmonitoragent_Node1', u'end_time': u'2019-07-31 
04:38:44:552121*None'}, u'log_vars': 
{u'event_id': u'UUID', u'start_time': u'TIMESTAMP', u'date_id': u'text', 
u'agent_id': u'text', u'end_time': u'TIMESTAMP'}}
\end{verbatim}
 
\labday{Wednesday, July 31, 2019}
This morning I checked the version of the cassandra-driver for python on the current machine. It is $3.18.0$ and the version on Bob's machine is $3.16.0.$ Also, after commenting out lines $135$ and $141$ in \texttt{Agents/TSDAgent/TSD/agent.py}, the same logging error was reported to the volttron log file. Thus, the function \texttt{do\_insertion\_jobs} is not the only problem rather also the \texttt{insert} and \texttt{customInsert} functions. In all, the cause of this problem will be very difficult to find as there are likely many calls to methods in the cassandra-driver package. In addition, another error is reported involving the VOLTTRON bacnet proxy agent when my machine is connected to both Wi-Fi and Ethernet. This problem is resolved if the host computer is only connected to the ECE-Robotics 1 network when running BEMOSS. A screencap is posted below.
\begin{figure}[h]
\center
\includegraphics[scale=0.3]{figs/bacnetAgentError.png}
\end{figure}
A attempt to correct the error was made by cloning BEMOSS into a new repository and ensuring the version $3.16.0$ was installed rather than the latest $3.18.0$. Next time, however, I need to dig deeper into the issue and understand it rather than use the "hack it until it works method". Due to time constraints, I used this method instead. The TSD agent errors were no longer present; however, another possible unrelated error was thrown by the network agent:
\begin{Verbatim}[tabsize=4]
Traceback (most recent call last):
  File "/home/ramgroup/tests/BEMOSS3.5/volttron/platform/
  vip/agent/subsystems/rpc.py", line 168, in method
    return method(*args, **kwargs)
  File "/home/ramgroup/tests/BEMOSS3.5/volttron/platform/vip/
  agent/subsystems/pubsub.py", line 262, in _peer_push
    callback(peer, sender, bus, topic, headers, message)
  File "/home/ramgroup/.volttron/agents/
  90ab11e3-bdb4-45e7-95c7-c3cbf682b92b/networkagent-0.1/network/agent.py", 
  line 222, in on_match_change
    self.curcon.commit()
  File "/home/ramgroup/tests/BEMOSS3.5/
  bemoss_lib/utils/db_helper.py", line 82, in reconnect
    return func(*args,**kwargs)
  File "/home/ramgroup/tests/BEMOSS3.5/
  bemoss_lib/utils/db_helper.py", line 109, in commit
    return self.con.commit()
IntegrityError: insert or update on table "node_device" 
violates foreign key constraint 
"node_device_assigned_node_id_cba9785e_fk_node_info_node_id"
DETAIL:  Key (assigned_node_id)=(0) is not present 
in table "node_info"
\end{Verbatim}
Unfortunately, as time went on the errors involving the TSD agent appeared again. At this point I have very little idea what is causing the issue. I do have a theory that the replaced URL is causing problems. So I will run a few tests:
\begin{enumerate}
\item Run BEMOSS with resource from old link (\texttt{dsc-cassandra-3.0.9-bin.tar.gz}) with cassandra-driver $3.16.0$ on ramgroup laptop
\item Run BEMOSS with resource from old link (\texttt{dsc-cassandra-3.0.9-bin.tar.gz}) with cassandra-driver $3.18.0$ on ramgroup laptop
\end{enumerate}
Number 1 could not be done as the cassandra directory cannot simply be transferred from one BEMOSS directory to another when installing. After performing 2, the same TSD agent errors occurred leading me to strongly believe that this has something to do with the python cassandra driver. I will run BEMOSS again with the new link and cassandra-driver $3.16.0$. The version of the cassandra-driver packaged is changed with the command \texttt{pip install cassandra-driver==version} after running the command \texttt{. env/bin/activate} to run the previous command in the BEMOSS virtual environment. After further testing I found that errors will be thrown by the time-series database agent with the cassandra-driver $3.16.0$ only when BEMOSS run is run for the first time.

\labday{Thursday, August 1, 2019}
On line 2852 of cluster.py:
\begin{verbatim}
log.debug("[control connection] Opening new connection to %s", host)
\end{verbatim}
After emailing Ashraf, the problem found yesterday is not an error as BEMOSS initializes some parameters when run the first time. So, once running the problems disappear. No more work needs to be done on this issues. The July 31 deadline was not successfully for the fully functional motor interface as the statistics chart for the motor did not appear aftre identifying and controlling the motor although the chart did appear one time.
\bigbreak\noindent
I spent some time learning about VOLTTRON on \url{https://volttron.readthedocs.io}

\labday{Friday, August 2, 2019}
The presentation was practiced today and a few additions were made. After reading a section on Agent mobility on the VOLTTRON documentation, I decided that I would like to implement ssh key host authentication to remove the password inconvenience of controlling the raspberry pi. Running the command 
\begin{verbatim}
ls .ssh
\end{verbatim}
showed only the file \texttt{known\_hosts} so no private or public keys had been generated previously. Then the command
\begin{verbatim}
ssh-keygen
\end{verbatim}
was run and the keys were placed into the \texttt{\textasciitilde/.ssh} directory. Lastly, the command \texttt{ssh-copy-id pi@192.168.1.41} was executed to send the public key generated on the BEMOSS host machine to the RPi. A login was prompted for and the system password of the ramgroup machine was entered. After this the process was succesfully completed. Now by simply running the command \texttt{ssh pi@<IP-ADDRESS>} commands can be executed. This was followed from the tutorial at \\
\url{https://www.raspberrypi.org/documentation/remote-access/ssh/passwordless.md}\\

\labday{Monday, August 5, 2019}
Research was done on the publish subscribe model that volttron uses to communicate between agents. Publishers (analogous to server entities) publish topics to a message queue which are then subscribed to by subscribers (analagous to clients). A subscriber can subscribe to multiple publishers and a publisher can publish to multiple subscribers. The intention was to have a Skype meeting with Ashraf at 7:00 pm cst today, but the call was never made; thus, another day much be chosen for working on completing the interface.

\labday{Tuesday, August 6, 2019}

\labday{Wednesday, August 7, 2019}
Ubuntu 16.04 was reinstalled on the ramgroup laptop due to some package issues after attempting to install octave via the command line. The section 3 Example 2: Smart Appliance Scheduling was read in \cite{ch05dynamicprogramming}. The optimal time to run a six-cycle dishwasher between $17:00$ and $24:00$ was analyzed with an electricity price that changes over time. The goal is to minimize
\[
	\sum_{k=0}^{N-1}\frac{1}{4}c_{k} p(x_k+u_k)u_k	
\]
where $c_k$ is the electricity cost in USD/kWh, k refers to each $15$ minute time period, $N$ is the final period, $p(x_k+u_k)$ is the power required by cycle $x_{k+1}=x_k+u_k$, and $u_k \in \{0,1\}$ is the control variable determing whether the dishwasher should maintain its cycle or move to the next cycle.
\bigbreak\noindent
Next Monday, I will have a meeting with Ashraf about adding the new device API.

\labday{Thursday, August 8, 2019}
The principle of optimality can be expressed as the equation $V_k(x_k)$ or the cost-to-go from time index $k$ to $N$. In this problem example, the equation is
\[ 
	V_k(x_k)=min\left\{V_{k+1}(x_k), \frac{1}{4}c_kp(x_k+1)+V_{k+1}(x_k+1)\right\}
\]
In other words, a decision must be made whether to continue with the last state or continue to the next state depending on which option is cheaper. Overall, conclusions were made about when the cycles of the dishwasher should be started according to when the electricity cost $c_k$ is lowest in the given time frame. This concept can be extended to really any stateful device that uses energy in a building. Using real power cost statistics from the web, this algorithm could be implemented within BEMOSS.

\labday{Friday, August 9, 2019}
While reading the article \cite{khamphanchai2015}, some interesting facts were discovered about BEMOSS. One is that lighting loads, plug load, and hvac controllers account for almost 75\% of loads in small and medium sized buildings. In the research going forward, it would be ideal to focus efforts on implementing one of these types of devices as they have the most relevance. Section IV A. discusses the agent architecture. In a path of control agent execution, the following steps are followed:
\begin{enumerate}
\item Obtain the configuration for the agent which contains the agent id, agent message pub/sub address
\item Instantiate a new device API object for communicating, monitoring and controlling the device
\item Setup variables and connect with databases (time-series and metadata)
\item Monitor the status of the device with device monitor agent behavior
\item After receiving a message from the UI, one of the behaviors (UpdateDeviceStatus, DeviceControl, IdentifyDevice) is triggered
\end{enumerate}
Periodically, the control agent will update its knowledge on what is knows about a device based on the setup monitoring period. The identify device behavior is for identification of a device according to its corresponding control agent. Section IV E. discusses application development. The process involves many different steps. Different examples of applications are demand response, price-based management, and load control based on local conditions. It may be interesting to implement the dynamic programming algorithm that was mentioned in the previous lab notebook entry by using demand response signals (OpenADR) from the cloud. As mentioned before, I would like to implement another either lighting, plugload or hvac controller.  At first, I thought of adding a wifi enabled dimmer switch but this has actually been already added (WeMo dimmer). This was realized after looking in the script \texttt{BaseAPI\_WeMo.py}. Official support has not been added yet for the device as seen on the supported device table on \url{www.bemoss.org}. Other options will need to be researched then.
\bigbreak\noindent
A test was made to isolate the issue of the chart not appearing by configuring the motor as a plugload and running BEMOSS. The chart appeared normally. 

\labday{Monday, August 12, 2019}
After the meeting with Ashraf, it was concluded that I must find how to add the new device type to BEMOSS alone as this is an open-source project and the development team only supports lighting, HVAC, and plugload controllers. In \texttt{bemoss\_install\_v3.5.sh}, on line $62$, the \texttt{defaultDB.py} program is run which is where the device types are added to the PostgreSQL database:
\begin{verbatim}
python Web_Server/run/defaultDB.py
\end{verbatim}
A copy of \texttt{charts\_plugload.html} was added to the directory\\ 
\texttt{PROJECT\_DIR/Web\_Server/webapps/charts/templates/charts} and renamed to \texttt{charts\_motor.html}. In addition, a directory named motor was added in the directory\\
 \texttt{PROJECT\_DIR/Web\_Server/webapps/device/templates}. Inside the motor directory, a copy of the \texttt{plugload.html} file was added and renamed to \texttt{motor.html}. The webapp html template \texttt{manual\_discovery.html} was modified by copying lines $192$ to $213$ and pasting them below the lines for the plug load controllers. Then, line $57$ of\\
\texttt{PROJECT\_DIR/Web\_Server/webapps/discovery/views.py} was changed to 
\begin{verbatim}
motors = SupportedDevices.objects.filter(device_type_id=5)
\end{verbatim}
and line 71 was changed to 
\begin{verbatim}
devices = {'hvac': hvac, 'lt_loads':lt_loads,
 'plugloads':plugloads, 'sensors':sensors, 'motors':motors}
\end{verbatim}
With these changes, BEMOSS was restarted and tested. Then in the \texttt{API\_info} method in the \texttt{API\_motor.py} script, the device type id of the motor was set to 5.
\bigbreak\noindent
Another issue appeared when no device appeared on the list supported devices on the discovery page. This was resolved by updating the html in the \texttt{manual\_discovery.html} file for the motor widget.
\bigbreak\noindent
I found another error when discovering the pittman motor. The device discovery agent receives an empty message when it subscribes to the message sent by the manual discovery views function \texttt{discover\_new\_devices}. This was fixed after making further changes to the django template code in \texttt{manual\_discovery.html}.
\bigbreak\noindent
Now the goal is to fix the chart issue. Some research was done in the file\\
\texttt{PROJECT\_DIR/Web\_Server/webapps/charts/views.py}. 
Print statements were added in the \texttt{returnChartsPage} to check if some sort of exception is being thrown. In the file \texttt{charts\_plugload.js} on line 80, a TypeError is thrown in the firefox developer console on the statistics page for the motor:
\begin{verbatim}
TypeError: _status[0] is undefined
\end{verbatim}
This is the problematic javascript object:
\begin{verbatim}
axes: {
			      xaxis: {
			        label: "Time",
			        renderer: $.jqplot.DateAxisRenderer,
			        tickOptions:{formatString:'%m/%d, %H:%M'},

		            min : _status[0][0],
		            max: _status[_status.length-1][0]
			      }
\end{verbatim}
To test whether this is the cause of the problem I will change the \texttt{device\_type\_id} of the motor back to $3$ corresponding to plugload as the chart appears when the device is set as a plugload. If the error is not shown in the console, then this must be the problem. The \texttt{\_status} variable is defined in \texttt{charts\_plugload.js} as \texttt{\_status = \{\{ status|safe|list\_if\_none \}\};} A \texttt{console.log} statement was added to determine the value of \texttt{\_status}. The \texttt{status} variable is a key in the dictionary \texttt{data\_dict} rendered to the page by the \texttt{charts/view.py} file by the function \texttt{returnChartsPage}. The value corresponding to \texttt{'status'} is an empty list which is the source of the issue. Tomorrow in the lab, I will check this dictionary when controlling the wemo insight switch.

\labday{Tuesday, August 13, 2019}
The result set printed to the terminal for the insight switch was similar to that printed for the motor other than the power variable. This is the variable list and result set used in the \texttt{returnChartsPage} function for the motor:
\begin{verbatim}
variable list:
[u'agent_id', u'date_id', u'status', u'time', u'user']
result set:
[[u'GM82_b827ebbfbade' u'2019-08-13' u'None' 1565704113458
  u'device_monitor']
 [u'GM82_b827ebbfbade' u'2019-08-13' 0 1565704188459 u'Admin_']]
\end{verbatim}
Also, this is the data dictionary rendered to the charts page by the \texttt{returnChartsPage} function:
\begin{verbatim}
{u'status': [], 'mac': u'b827ebbfbade', 'nickname': u'Plugload2', 
'node_name': u'Node1'}
\end{verbatim}
For the Insight switch, the variable list and result set are:
\begin{verbatim}
variable list:
[u'agent_id', u'date_id', u'power', u'status', u'time', u'user']
result set:
[[u'Insi_231707K120123A' u'2019-08-13' 0.0 0 1565703938458
  u'device_monitor']
 [u'Insi_231707K120123A' u'2019-08-13' None 1 1565703963458 u'Admin_']
 [u'Insi_231707K120123A' u'2019-08-13' None 0 1565703968466 u'Admin_']]
\end{verbatim}
The data dictionaries are:
\begin{verbatim}
{u'status': [[1565703938458.0, 0.0], [1565703963457.0, 0.0], 
[1565703963458.0, 1.0], [1565703968465.0, 1.0], [1565703968466.0, 0.0], 
[1565704485071.0, 0.0]], 'mac': u'231707K120123A', 
'nickname': u'Plugload1', 'node_name': u'Node1'}
{u'status': [[1565703938458.0, 0.0], [1565703963457.0, 0.0], [1565703963458.0, 1.0], 
[1565703968465.0, 1.0], [1565703968466.0, 0.0], [1565704485071.0, 0.0]], 
'mac': u'231707K120123A', 'nickname': u'Plugload1', u'power': 
[[1565703938458.0, 0.0], [1565704485071.0, 0.0]], 
'node_name': u'Node1'}
\end{verbatim}
One difference noticed is that for all lists in the result set the status is set to \texttt{None} when the user is \texttt{Admin\_} for the motor. In the \texttt{parse\_resultset} function, the line
\begin{verbatim}
x = [[lst[variables.index('time')], 
lst[variables.index(data_point)]+0.0]s
                for lst in result_set 
                if lst[variables.index(data_point)] is not None]
\end{verbatim}
will not return a list for each list in \texttt{result\_set} if the value of \texttt{status} is \texttt{None}. However, some values should still be returned as the value of \texttt{status} is not \texttt{None} when the user is \texttt{Admin\_}.
\bigbreak\noindent
The reason why \texttt{parse\_resultset} is returning an empty list is the line
\begin{verbatim}
if len(result_set)>0 and type(result_set[0][variables.index(data_point)]) 
in [str,unicode]:
	return []
\end{verbatim}
From the \texttt{result\_set} shown above,\\ 
\texttt{result\_set[0][variables.index('status')] = u'None'} which is a unicode string thus the \texttt{parse\_resultset} function is returning an empty list. The next step I took in solving this issue is by looking in the motor api code. Since the WeMo insight switch is working perfectly, there is likely a problem with the API code I wrote for the motor. I may need to compare the two device API's to see if there  are any differences. As a test I commented out the conditional statement mentioned above. This did not appear to fix the problem. From the looking at the \texttt{result\_set} data, once BEMOSS is started the new \texttt{status} values are not \texttt{u'Null'}. The \texttt{u'Null'} values were likely saved in the table when there was a mistake in the motor api code. The data in this table is still present upon restart, so a way must be found to delete the data in the table. First, I will I try to change the device type to motor rather than plugload.
\bigbreak\noindent
The \texttt{cassandraDB.py} file contains a function named \texttt{delete} that is able to drop a table in the cassandra database. It takes a single argument, the agent id corresponding to the table to be dropped. When I called this function within a python interpreter in the \texttt{PROJECT\_DIR/bemoss\_lib/databases/cassandraAPI/} directory, errors were thrown but the operation seemed to complete sucessfully. There seems to be some problem with this function as \texttt{startDate} and \texttt{endDate} were not specified but errors were thrown by the pandas module although they are not required. However, the table was still deleted even when these parameters were not specified. After restarting BEMOSS with tables not present in the cassandra database, the chart appeared successfully on the statistics page. Lastly, another issue still exists on the dashboard discovery page. When I press the "Set all to 'Approved'" button, the device \texttt{Approval status} does not update. In \texttt{PROJECT\_DIR/Web\_Server/static/app\_js/discovery.js},  the following code was added on lines $321$ to $324$: 
\begin{verbatim}
    $("#set_approve_Motor").click(function(e)) {
        e.preventDefault();
        $(".app_stat_Motor").text("Approved");
    }
\end{verbatim}
The \texttt{event.preventDefault} method will prevent the default action from being triggered and will not reload the page. This problem was not solved by performing the above action. After pressing the \texttt{Save Change to Motor Controllers} button, a popup is generated by firefox: 
\bigbreak\noindent
To display this page, Firefox must send information that will repeat any action (such as a search or order confirmation) that was performed earlier.
\bigbreak\noindent
This issue was resolved by changing parenthesis and brackets of the above code as follows:
\begin{verbatim}
    $("#set_approve_Motor").click(function(e) {
        e.preventDefault();
        $(".app_stat_Motor").text("Approved");
    });
\end{verbatim}

\labday{Wednesday, August 14, 2019}
In a short meeting with Dr. Miah, we discussed issues with the motor. He found that something is shorting out causing the power supply to overload. This was quickly fixed by reinserting the twisted pair of wires into the screw terminals of the h-bridge driver.
\bigbreak\noindent
Another issue with the software is when a plugload controller is discovered after discovering the motor, the nickname of the plugload controller (for example insight switch) is \texttt{plugload2} rather than \texttt{plugload1}. A likely reason is no changes were made to the html template after copying the plugload template and renaming to \texttt{motor.html}. After looking through the device discovery agent code, in the  \texttt{DiscoveryAgent} constructor \texttt{self.device\_num} is set to the number of devices discovered by the device discovery agent. Once a new device is discovered, in the \texttt{findDevices} method, the \texttt{self.device\_num} variable is incremented, so the number after the device type refers to the total number of devices that have been discovered rather than the number of devices of the specific type that have been discovered. Later work was done on the presentation here are the topics:
\begin{itemize}
	\item API translator discussion
	\item Adding a device API translator
	\item Adding a new device type
	\item Problems fixed
	\item Additions
	\item Priorities
\end{itemize}

\labday{Thursday, August 15, 2019}

\labday{Friday, August 16, 2019}

\labday{Monday, August 19, 2019}
In the lab, when demonstrating the motor interface to Dr. Miah, the scheduling for the motor type has not been implemented. For now, this is fine as I do not have time at the moment. Later this could be useful in scheduling the motor to turn on based on responses from the grid. During the filming of a video demonstration of the progress I have made so far, the number displaying the number of discovered devices in the discover/manage tab appears to be incorrect when both the insight switch and motor are discovered (i.e. 1 is displayed when both devices are discovered rather than 2). One of the Python files likely does not contain code for the motor controller. This is the django template code used to display the number of devices next to the label of the tab:
\begin{verbatim}
	{% get_value_with_default device_count 'PND' 'all' 'all' 0 %}
\end{verbatim} 
Arguments \texttt{device\_count}, 'PND', 'all', 'all', and 0 are passed as arguments into the template tag \texttt{get\_value\_with\_default}. However, I do not know where \texttt{device\_count} is defined. \texttt{device\_count} is a dictionary returning the number of devices under each approval status such as pending, approved, or non-bemoss device.

\labday{Tuesday, August 20, 2019}
Today, I will document the full procedure for adding the motor to BEMOSS. Note \texttt{PROJECT\_DIR} refers to the directory containing the installation of BEMOSS. For example, \texttt{\textasciitilde/BEMOSS3.5}.
\begin{enumerate}
\item Add the files \texttt{BaseAPI\_RPi.py} and \texttt{API\_Motor.py} to the directory \texttt{research} in the BEMOSS project directory. These are available on the Google Drive BEMOSS-Brian2019
\item In the file \texttt{PROJECT\_DIR/bemoss\_lib/utils/platform\_initiator.py}, replace the line \texttt{APImodule = importlib.import\_module("DeviceAPI."+file)} on line 247 with 
\begin{Verbatim}[tabsize=4]
try:
	APImodule = importlib.import_module("DeviceAPI."+file)
except Exception as er:
	APImodule = importlib.import_module("research."+file)
\end{Verbatim}
This will allow the platform initiator to search both the \texttt{PROJECT\_DIR/DeviceAPI} and \texttt{PROJECT\_DIR/research} directories for device API files.
\item In the discovery agent code\\
\texttt{PROJECT\_DIR/Agents/DeviceDiscoveryAgent/devicediscovery/agent.py},\\
on line 167, replace \texttt{apiLib = importlib.import\_module("DeviceAPI."+self.api)} with
\begin{Verbatim}[tabsize = 4]
try:
	APImodule = importlib.import_module("DeviceAPI."+file)
except Exception as er:
	APImodule = importlib.import_module("research."+file)
\end{Verbatim}
to allow the basic agent to search both directories \texttt{PROJECT\_DIR/DeviceAPI} and \texttt{PROJECT\_DIR/research} for device AIP files.

\item Update the python script\\
\texttt{PROJECT\_DIR/Web\_Server/run/defaultDB.py} with the line 
\begin{verbatim}
dt5 = DeviceType(id=5, device_type='Motor')
dt5.save()
\end{verbatim}
to register the device type \texttt{Motor} in the BEMOSS database.
\item Update the html template\\
\texttt{PROJECT\_DIR/BEMOSS3.5/Web\_Server/webapps/discovery/\\
templates/discovery/manual\_discovery.html},\\
by copying the html for the plugload widget and pasting below to create a widget for motors on the manual discovery page. Then replace the variables \texttt{plugloads} with \texttt{motors} and \texttt{eachpl} with  \texttt{eachmot} in the copied html.

\item Update the django view\\
\texttt{PROJECT\_DIR/Web\_Server/webapps/discovery/views.py} by replacing \texttt{power\_meters} with \texttt{motors} on line 58 as such
\begin{verbatim}
motors = SupportedDevices.objects.filter(device_type_id=5)
\end{verbatim}
On line $70$ of the file, add the key value pair \texttt{'motors': motors} to the \texttt{devices} dictionary that is rendered to the \texttt{manual\_discovery.html} file.

\item In the directory, \texttt{PROJECT\_DIR/Web\_Server/webapps/device/templates} copy the directory \texttt{motor} and rename to \texttt{motor} and rename the html template \texttt{plugload.html} to \texttt{motor.html}.

\item In the directory, \texttt{PROJECT\_DIR/Web\_Server/webapps/charts\\
/templates/charts/} copy the file \texttt{charts\_plugload.html} into the directory and rename the file to \texttt{motor.html}.
\end{enumerate}

Note: other steps will likely be required here due to the bug regarding the number of devices.

\labday{Wednesday, August 21, 2019}
As a continuation of yesterday, further code must be added to the file
\begin{verbatim}
PROJECT_DIR/Web_Server/static/app_js/manual_disc.js
\end{verbatim}
I have almost no knowledge of javascript and thus jQuery, so I do not understand this code.

The lines 
\begin{verbatim}
$(".eq_height_mot").height(ht);
\end{verbatim}
and 
\begin{verbatim}
    $("#mot_all").change(function() {
        if($(this).is(":checked")) {
            $("input[id^=mot_]").prop('checked', true);
        } else {
            $("input[id^=mot_]").prop('checked', false);
        }
    });
\end{verbatim}
must be added. Also, the expression
\begin{verbatim}
!(current_id == "mot_all")
\end{verbatim} 
must be added to line $189$ of \texttt{manual\_disc.js}.
\bigbreak\noindent
I will likely need to make a pdf file with these steps and place them in the Google Drive for better accessibility. 
\bigbreak\noindent
Since the RPi was automatically connecting to BUGuest, I found a tutorial online to forget the saved wifi network. By using the command,
\begin{verbatim}
sudo nano /etc/wpa_supplicant/wpa_supplicant.conf
\end{verbatim}
the wifi network corresponding to BUGuest was deleted including the name and network block. Hopefully, this will prevent the Pi from connecting to BUGuest and only connect to ECE-Robotics$1$.
\bigbreak\noindent
I found another error in the software. When clicking on the "Delete Data" button in the BEMOSS advanced settings in the advanced settings GUI, this exception is thrown:
\medbreak
\begin{verbatim}
Traceback (most recent call last):
  File "/usr/lib/python2.7/lib-tk/Tkinter.py", line 1540, in __call__
    return self.func(*args)
  File "GUI.py", line 385, in del_dat
    shutil.rmtree(cas_data_dir)
  File "/usr/lib/python2.7/shutil.py", line 239, in rmtree
    onerror(os.listdir, path, sys.exc_info())
  File "/usr/lib/python2.7/shutil.py", line 237, in rmtree
    names = os.listdir(path)
OSError: [Errno 2] No such file or directory: 
'/home/ramgroup/BEMOSS3.5/cassandra/data'
\end{verbatim}
The data directory is not present in the cassandra directory. For now, to delete the data from the database, I will simply just remove the table by using the function call:
\medbreak
\begin{verbatim}
cassandraDB.delete(agent_id)
\end{verbatim}
where \texttt{agent\_id} is the \texttt{agent\_id} corresponding to the cassandra database table.
%----------------------------------------------------------------------------------------
%	BIBLIOGRAPHY
%----------------------------------------------------------------------------------------
\labday{Thursday, August 22, 2019}
While researching sources for the paper, I found this source \footnote{\url{https://lucidconnects.com/library/blog/electricity-demand-vs-consumption}} to help me understand a little more terminology used in this project:
\begin{itemize}
\item Peak demand - highest average demand during a $15$ period in the utility cycle
\item Time-of-use pricing - electricity rate is charged based on the time of day
\end{itemize}

\labday{Friday, August 24, 2019}
A current challenge that I am facing is finding an article that discusses the vast number of electrical devices in the world such as electric vehicles, smart phones, computers, and other electrical appliances. One source I found was from the IEC - International Electrotechnical Commission.  

\labday{Tuesday, October 8, 2019}
Some research was done on the kill a watt meter. The wireless version of the Kill A Watt meter - P$3$ $4250$ CO2 Wireless is no longer in stock. A brochure for this device can be found at the link \url{http://p3international.com/brochures/p4200.pdf}. Some of the features of this device include calculation of carbon emission and energy costs by day, week, month, and year. The software controlling the wireless display can be configured to take KWh data in combination with the type of electricity generation, coal, hydroelectric, nuclear. This device may be very difficult to implement as it uses a $916.5$ MHz wireless transmitter rather than a Wi-Fi interface as it is an outdated product. Additional hardware will be needed such as a receiver that can accept $916.5$ MHz frequencies. The data obtained from the receiver will then need to be sent to the RPi and then to BEMOSS over Wi-Fi. In all, this device may or may not be possible to implement within BEMOSS inside the given time frame which is from now until Dec $1$. Also, purchasing an outdated product that is not widely used is not advisable.
\smallbreak\noindent
On the other hand, the P$3$ P$4400$ Kill A Watt is widely available on many different sites; however, it is not a wireless device. Thus, some soldering will need to be done and work around AC mains voltage which I personally deem to be unsafe. Mr. Mattus will also not likely allow me to work with mains voltage in the lab unless I could find a more experienced person to perform hardware modifications to the Kill A Watt. Also, a second downside to implementing this non-wireless meter is the fact that Dr. Miah prefers working with a fully functional device rather than one requiring modification.
\smallbreak\noindent
In conclusion, I don't think that implementing either of these devices will work out as it will likely require more time than allocated to perform the task (two months). 
\smallbreak\noindent
In the meeting it was decided to work on implementing a new load whose power consumption will be monitored with the Insight Switch.

\labday{October 15, 2019}
Today, new loads were researched on the Web. Some of the openHAB documentation was read over to find any loads that could be controlled over a LAN. One obvious one is computer/server as they tend to consume a lot of energy. From the url \url{https://www.openhab.org/docs/configuration/items.html}, under the section on multi binding/ channel linkage, interaction with an office pc is described. Network health and power consumption are monitored with a network health binding and wake-on-lan binding respectively.
\smallbreak\noindent
More research was done on the Wake-On-LAN networking standard on wikipedia (\url{https://en.wikipedia.org/wiki/Wake-on-LAN}). A network message may be sent to a computer to turn on or awaken the machine. The device sending the message must be connected to the same LAN as the target PC. To implement on a wireless network, wake on wireless LAN must be used. However, after some further searching WoWLAN appears to have some serious limitations compared to WoLAN. Lastly, a computer can be in 7 different power states which are listed in Figure~\ref{figs:powerstates}.
With these states it may be possible to implement a dynamic programming algorithm to optimize the power consumption of the computer. However, I am not sure how to control these power states using the Wake on LAN, or if it is even possible.

\labday{October 22, 2019}
It was found that Wake On LAN is only able to wake computer from sleep or powered off state. Thus, more research will need to be done in order to find a way of controlling these states. At the url, \url{https://docs.microsoft.com/en-us/windows/win32/power/using-the-device-power-api?redirectedfrom=MSDN} I found some example c++ code of using the device power api on windows.

\begin{Verbatim}[tabsize=4]
#define _WIN32_WINNT 0x0600
#include <Windows.h>
#include <PowrProf.h>
#include <stdio.h>
#include <tchar.h>

#pragma comment(lib, "PowrProf.lib")

int __cdecl main()
{
 // Define and initialize our return variables.
 LPWSTR  pRetBuf = NULL;
 ULONG bufSize = MAX_PATH * sizeof(WCHAR);
 ULONG uIndex = 0;
 BOOLEAN bRet = FALSE;

 // Open the device list, querying all devices
 if (!DevicePowerOpen(0)) 
  {
   printf("ERROR: The device database failed to initialize.\n");
   return FALSE;
  }

 // Enumerate the device list, searching for devices that support 
 // waking from either the S1 or S2 sleep state and are currently 
 // present in the system, and not devices that have drivers 
 // installed but are not currently attached to the system, such as 
 // in a laptop docking station.

 pRetBuf = (LPWSTR)LocalAlloc(LPTR, bufSize);

 while (NULL != pRetBuf && 
        0 != (bRet = DevicePowerEnumDevices(uIndex,
           DEVICEPOWER_FILTER_DEVICES_PRESENT,
           PDCAP_WAKE_FROM_S1_SUPPORTED|PDCAP_WAKE_FROM_S2_SUPPORTED,
           (PBYTE)pRetBuf,
           &bufSize)))
  {
   printf("Device name: %S\n", pRetBuf);

   // For the devices we found that have support for waking from 
   // S1 and S2 sleep states, disable them from waking the system.
   bRet = (0 != DevicePowerSetDeviceState((LPCWSTR)pRetBuf, 
                                  DEVICEPOWER_CLEAR_WAKEENABLED, 
                                  NULL));

   if (0 != bRet) 
    {
     printf("Warning: Failed to set device state.\n");
    }
   uIndex++;
  }

 // Close the device list.
 DevicePowerClose();
 if (pRetBuf!= NULL) LocalFree(pRetBuf);
 pRetBuf = NULL;

 return TRUE;
 if (pRetBuf!= NULL) LocalFree(pRetBuf);
 pRetBuf = NULL;
}
\end{Verbatim}

\labday{Tuesday, October 29, 2019}
Because of the small amount of time to integrate the new device (around 1 month) while only working around 2 hours per week, a different device was chosen instead of Desktop PC/server. Also, many downsides to working with these devices were found. The major problem is that the wemo switch alone can already handle shutting down and turning on a computer (although in an unideal way via hard shutdown rather than through the operating system). Secondly, switching the pc to other power states than simply off or on such as sleep or hibernate may not be possible through the operating system or using IPMI, and one of the main original motivations for implementing the remote LAN power control technologies is to control the power states. However, in the future, wake-on-lan or possibly IPMI could be implemented.
\smallbreak\noindent
Thus, I decided to work on implementing a stepper motor to complement the DC motor worked on previously. Also, this project may be more interesting than simply turning on and off a computer remotely. The motor used is the 28BYJ-48 5V unipolar stepper motor. Some of the specs of the motor from the data sheet at \footnote{\url{https://download.mikroe.com/documents/datasheets/step-motor-5v-28byj48-datasheet.pdf}} include
\begin{itemize}
\item 4 phases
\item 1/64 speed variation ratio
\item 100 Hz frequency
\item 5 V DC operating voltage
\end{itemize}
At the moment, my stepper motor knowledge is limited so programming the device will require a great deal of research.

\labday{Tuesday, November 5, 2019}
In addition to the stepper motor, a ULN2003A darlington transistor array is used to amplify the supply power. The IC is mounted on the ULN 2003 stepper motor driver board. I ran the python program provided in the Github repository \footnote{\url{https://github.com/Freenove/Freenove_Ultimate_Starter_Kit_for_Raspberry_Pi.git}}; and connected the stepper driver and power supply breakout board to the Raspberry GPIO extension board according to the wiring diagram provided in the file \texttt{Tutorial.pdf}. However, the stepper motor was not functioning at all and the LEDs on the driver board that indicate which coil is being powered were not lighting up. Also, the board became very hot to the touch when connected to the RPi and power supply module. A potential reason is the fact that a 12 V power adapter is used to power the power supply module rather than the likely recommended 5 V. A second reason is the differences between the RPi model 3 and 3B+ that I use personally. I will need to test the python script on my own raspberry Pi to see if this is the cause of any problems. 
\labday{Tuesday, November 12, 2019}
After the RAM group meeting on Friday Nov. 8, a member of the robot localization group commented on my idea for integrating a stepper motor. He asked about whether there was any actual way that the stepper motor can be linked to energy efficiency. To this day, I have not found a single way that the motor can be used to control a device that can help to lower energy consumption in a home or building. Over the weekend, I came upon a new IoT product on the market named the Sensibo Sky \footnote{\url{https://sensibo.com/products/sensibo-sky}} which is a smart air conditioner controller. This product is similar to the Google Nest thermostat; however, it is used to control standalone air conditioners rather than the central HVAC system. It is capable of connecting to any air conditioner that uses an IR remote control. Some of the features of the device include 7-day scheduling, geofencing (a way determine whether occupants are in a house), control of AC unit on/off status, and fan speed. It claims to be compatible with IFTTT (If This Then That), Amazon Alexa, and Google Home. A potential challenge would be finding an air conditioner to control; for sure, it would not be feasible to work with controlling it in the lab due to potential safety risks/fire hazards. Another idea would be to control an AC unit in my own home. However, the first step will be to find a way of purchasing the Sky as the International version is fairly expensive at \$119 on Amazon.

\labday{Thursday, November 14, 2019}
While waiting for a response from Dr. Miah about purchasing the new device, I worked on updating the motor device page by adding scheduling. The first I took was to set the variable DEBUG in the django web server settings file to true. This enables changes in each django application html template to be seen after refreshing the page. In addition, whenever a server-side error occurs detailed information will be displayed in the browser about where the error occurred. Before when this variable was set to false, the web server had to be restarted every time changes were made. 
\smallbreak\noindent
After uncommenting the set schedule button in the template for the motor device page named "motor.html", the following error is displayed

This message means that the \texttt{showSchedule} view function is returning an error as there is no \texttt{motor\_schedule} view function defined whose output should be returned by the \texttt{showSchedule} function.

\labday{Tuesday, November 19, 2019}
Work was continued on developing the schedule app for the motor. the code in the body of the function \texttt{plugload\_schedule} was copied into the new view function \texttt{motor\_schedule}. However, a few modifications were made to the code by adding two new dictionaries into the file \texttt{Web\_Server.\_utils.defaults.py} named \texttt{MOTOR\_DEFAULT\_SCHEDULE} and \texttt{DISABLED\_VALUES\_MOTOR} and replacing their plugload equivalents in the copied code with the new versions. Also, a new html template was added named \texttt{motor\_schedule.html}. When selecting the Set Schedule button on the motor dashboard page, the following exception occured.
\begin{Verbatim}
File "/home/ramgroup/BEMOSS3.5/Web_Server/webapps/
schedule/views.py" in motor_schedule
  290.     
  user_group = request.user.group.all().values_list('name', flat=True)

File "/home/ramgroup/BEMOSS3.5/env/local/lib/python2.7/site-packages/django/utils/
functional.py" in inner
  239.         return func(self._wrapped, *args)

Exception Type: AttributeError at /schedule/b827ebbfbade/
Exception Value: 'User' object has no attribute 'group'
\end{Verbatim} 
I will need to research this problem as I do not know a lot about HttpRequests are handled in Django.

\labday{Tuesday, February 25, 2020}
Today, I worked on researching bootstrap which is a html and css framework for building responsive and resizable web pages. The following W3 Schools tutorial was followed 
\smallbreak\noindent
\url{https://www.w3schools.com/bootstrap4/}

Secondly, I created a simple Python http web server that I copied from this link
\smallbreak\noindent
\url{https://stackoverflow.com/questions/39801718/how-to-run-a-http-server-which-serves-a-specific-path}
The code is shown below:
\begin{Verbatim}
import http.server
import socketserver

PORT = 8000
Handler = http.server.SimpleHTTPRequestHandler
httpd = socketserver.TCPServer(("", PORT), Handler)
print("serving at port", PORT)
httpd.serve_forever()
\end{Verbatim}

\labday{Tuesday, March 3, 2020}
Because I found that having a good foundation for the web app is nice to have first, I decided to context switch to working on the back end of the site. In this way, I can build up the project directory and setup any necessary databases. Later I can move to working on the front which (for me at least) will be a much more difficult task as I have no background in web design. Instead of using the large, more complex full-stack web framework that BEMOSS uses, Django, I will use flask as it will decrease development time. This is necessary as I only have 1 year to develop the application. First, before the project is to be setup, I will upgrade the laptop to Ubuntu 18.04 LTS from the current Ubuntu 16.04. This could potentially be a problem if I need to run BEMOSS from the laptop; however, a backup laptop is available. This tutorial from Medium was used:
\url{https://www.cyberciti.biz/faq/how-to-upgrade-ubuntu-16-04-to-18-04-lts-using-terminal/}
However, after running the command
\begin{Verbatim}
sudo do-release-upgrade
\end{Verbatim} 
I was notified at the end that the download will take roughly 18 minutes and the installation will take several hours, so this upgrade will have to wait for another day. At the url:
\url{https://flask.palletsprojects.com/en/1.1.x/quickstart/#a-minimal-application}, I followed the tutorial on how to use flask. In order to render python data to an HTML template, Flask provides an interface to do this directly by using templates. Calling the function \texttt{render\_template()} defined in the module flask will render to an html page provided in the first argument followed by keyword arguments to be rendered to the page. The template language in use is Jinja$2$.

\labday{Monday, March 16, 2020}
A break was taken from Flask work and web development to work on communicating with the ESP8266 Node MCU boards. Although full approval from the advisor has not been obtained yet, I would like to replace the XBee modules and RPi for communicating with motor. This way only one wireless communication protocol has to be used (Wi-Fi) rather than having to use two (Wi-Fi and Zigbee). I plugged in my board to the laptop which was instantly recognized as '/dev/ttyUSB0' by linux. Then, I downloaded the latest firmware from the URL:
\url{http://micropython.org/download#esp8266} (the latest bin file). The tutorial at \url{https://docs.micropython.org/en/latest/esp8266/tutorial/intro.html} was followed to flash firmware to the device. First, the flash was erased with the command:
\begin{Verbatim}
esptool.py --port /dev/ttyUSB0 erase_flash
\end{Verbatim}
However, this command threw an error stating the it could not open the port tty/USB$0$ due to a permission error. This was resolved by instead using the command:
\begin{Verbatim}
sudo python3 -m esptool --port /dev/ttyUSB0 erase_flash
\end{Verbatim}
Next the binary file was flashed to the chip using the command:
\begin{Verbatim}
sudo python3 -m esptool --port /dev/ttyUSB0 --baud 460800 write_flash 
--flash_size=detect 0 esp8266-20191220-v1.12.bin
\end{Verbatim}
After the firmware was flashed to the board, an REPL (Read Evaluate Print Loop) was obtained over serial by running the command:
\begin{Verbatim}
sudo picocom /dev/ttyUSB0 -b115200
\end{Verbatim}
This is simply a python interpreter that can run micropython. The module \texttt{machine} is used for performing different GPIO operations.

\labday{Thursday, March 19, 2020}
Work was done to flash a python program to the esp8266 board today. First the command 
\begin{Verbatim}
pip3 install adafruit-ampy
\end{Verbatim}
was used to install adafruit ampy for performing different operations on the board. 

\labday{Thursday, March 26, 2020}
A simple TCP/IP web server written in python was written which will continually accept client connections and receive bytes objects. Two different LEDs are used, GPIO$5$ corresponding to D$1$ and GPIO$4$ corresponding to D$2$. Once these bytes objects are decoded as UTF-$8$ strings, decisions are made based on which command was sent:
\begin{itemize}
\item 'ON' corresponds to toggling a GPIO pin on
\item 'OFF' corresponds to toggling a GPIO pin off
\item 'Q' will end the client session with the server
\item if an invalid command is entered the program will continue operation
\item 'PWM: <int:pwm value>' corresponds to setting the PWM value of a second LED
\end{itemize}
Once 'Q' is entered by the client, the client program will end, and the server will wait to accept another connection from a client. This program was added in the script \texttt{main.py}. In order to allow ampy to access the serial port \texttt{/dev/ttyUSB0}, the permissions must be modified using:
\begin{Verbatim}
sudo chmod 777 /dev/ttyUSB0
\end{Verbatim}
Then the command:
\begin{Verbatim}
ampy --port /dev/ttyUSB0 -b115200 put main.py
\end{Verbatim}
was run to flash the program to the board.
\smallbreak\noindent
The file \texttt{main.py} will automatically be run on board start up. To restart the program, the reset button on the board can be pressed. 
\smallbreak\noindent
To connect to the board a second program was written called \texttt{client.py} which will connect to the board with the IP hardcoded and assigned to a variable. In the future I will need a way to determine the OUI of the ESP$8266$ node MCU board, and determine the IP address of the board similar to the way the IP address of the RPi was determined. Once the client is connected to the server, the user will be prompted to enter a command in an infinite loop. If the string 'Q' is entered, the loop will break. The program \texttt{client.py} is designed to run on any computer capable of running python. This functionality will be implemented into the new platform by sending a command to the server whenever a button is pressed on the web page for the device.
\smallbreak\noindent
A directory was created in the DocsBEMOSS directory named \texttt{esp8266} which contains the server and client code as well as an example http server pulled from a micropython tutorial for the board available at \url{https://docs.micropython.org/en/latest/esp8266/tutorial/}.
\smallbreak\noindent
PWM control was added later on to prove that it can be possible to control the speed of a motor wirelessly if speed control is desired later on.
\smallbreak\noindent
The files \texttt{http\_server.py} and \texttt{test.py} were removed from the directory \texttt{esp8266/} as they contained stolen code.

\labday{Tuesday, April 7, 2020}
I created a github repository named \texttt{NewBEMS} for the project located at \url{https://github.com/blauer890/NewBEMS.git}. Later I will need to change this name; however we have not decided on a proper name for the software as of yet.

\labday{Friday, April 17, 2020}
Some of the major tasks that are required for the project were itemized in order of importance:
\begin{itemize}
\item Research, determine, and develop agents
\item Device API/Driver development
\item Microgrid Simulation
\item User management
\end{itemize}
Right now I will work on determining what agents should reside in the platform. A lot of inspiration will taken from the BEMOSS repository. 

\labday{Friday, May 1, 2020}
Some work was done on the Discovery Agent today. A method named \texttt{subscribe} was added that takes a topic as a parameter and passes it to an instance of a zmq socket. The socket connects to tcp server \texttt{tcp://localhost:5556} which is the server used for publishing and subscribing. For now, inside an infinite loop it waits for incoming messages and prints them out. The current topic the DiscoveryAgent is subscribing to is 'discovery' which could be published to from anywhere in the web app with a connection to the server. To allow the agent to perform other actions while awaiting for incoming messages, the subscriber method is started in a separate thread using the Python \texttt{threading} library. 
\smallbreak\noindent
Once a message has been received, it is parsed into the three different strings:
\texttt{topic, method, args}. The method refers to the name of the method that is to be called on the agent object.

\labday{Wednesday, May 20, 2020}
Today, I worked on implementing the device discovery feature in the web UI. Ideally, what I would like to have is a list of devices displayed as bootstrap list-group-items with radio button embedded in them pulled right. At the bottom under the list-group, a "Find devices" button will be present which once pressed will send a message to the Device Discovery agent to start finding devices on the LAN.
\begin{figure}[H]
\centering
\includegraphics[scale=0.35]{figs/img/deviceDiscoveryList}
\end{figure}
Once a device or devices have been discovered, I would like to add a pop up window to showcase the devices that were discovered. With the pop up window open the background should be faded and not selectable. However, my knowledge of javascript is still pretty low, so that my take a bit of time to figure out. One change that was made to the main container is that the padding left, right, top, and bottom were all set to 20px. This way, whenever new supported devices are added the size of the container grows vertically.
\smallbreak\noindent
As a small experiment, I ran the server on 0.0.0.0 to allow all devices on the network to access the software by changing the line in the \texttt{run.sh} script from 
\begin{verbatim}
flask run
\end{verbatim}
to
\begin{verbatim}
flask run --host=0.0.0.0
\end{verbatim}

\labday{Friday, May 22, 2020}
Work was continued on discovery today. I need to add python code into the html template discovery.html for loading all the supported devices into the page. This will require setting up the database. I created three CREATE TABLE statements in the \texttt{initialization.sql} file. The tables are \texttt{users}, \texttt{supported\_devices}, and \texttt{active\_devices}. 
At the end I added a statement to add a single row into supported devices table. The code is posted below:
\begin{Verbatim}
DROP TABLE IF EXISTS users;
DROP TABLE IF EXISTS supported_devices;
DROP TABLE IF EXISTS active_devices;

CREATE TABLE users (
  Id int NOT NULL AUTO_INCREMENT,
  Username varchar(255),
  Password varchar(255)
);

CREATE TABLE supported_devices (
  Name varchar(255),
  Manufacturer varchar(255),
);

CREATE TABLE active_devices (
  Id int NOT NULL AUTO_INCREMENT,
  Name varchar(255),
  Manufacturer varchar(255),

);

INSERT INTO supported_devices (Name, Manufacturer)
VALUES ('Insight Switch', 'Belkin');

\end{Verbatim}
Later I realized that the syntax of the code posted above is not appropriate for SQLite. Therefore, the code was changed to below:
\begin{Verbatim}
CREATE TABLE IF NOT EXISTS users (
  id INTEGER PRIMARY KEY,
  username TEXT NOT NULL,
  password TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS SupportedDevices (
  name TEXT,
  manufacturer TEXT
);

CREATE TABLE IF NOT EXISTS ActiveDevices (
  id INT PRIMARY KEY,
  name TEXT,
  manufacturer TEXT
);

INSERT INTO SupportedDevices (name, manufacturer)
VALUES ('Insight Switch', 'Belkin');

\end{Verbatim}

\labday{Monday, May 25, 2020}
I continued work on getting the devices pulled from the supported devices table into the discovery.html template via the Jinja2 template engine. In the disovery.py file which includes the view function to render data to the html file, the line \texttt{db.cursor.execute('SELECT * FROM SupportedDevices'}. However, I was having problems with the table \texttt{SupportedDevices} not being found in the database even though it is clearly added in the \texttt{initialization.sql} script I wrote. The same line was ran in the console using the flask debugger. It was found that the problem stemmed from the fact that the \texttt{WebServer} directory is not on the path when the server is run. This causes a problem when an attempt to connect to the database is made. Thus, the line \texttt{db = database.DBConnection('meta.db')} had to be changed to \texttt{db = database.DBConnection('./WebServer/meta.db')} where the database python module is a python file that contains the class \texttt{DBConnection} for performing different database operations. When the line without the relative path is specified, a file called 'meta.db' is created in the \texttt{\textasciitilde /NewBEMS} directory. The code for the \texttt{database} module is shown below.
\begin{Verbatim}
import sqlite3

class DBConnection:
    def __init__(self, db_name):
        self.db_name = db_name
        self.conn = sqlite3.connect(self.db_name)
        self.cursor = self.conn.cursor()

    def close(self):
        self.cursor.close()
        self.conn.close()
\end{Verbatim}
After performing this change, the \texttt{discovery.html} page loaded properly in the browser.
\smallbreak\noindent
Since it makes things more convenient to have the device manufacturer first and device name second, I changed around the order of these rows in the Supported Devices table. Accordingly, I updated the \texttt{findDevices} function used by the \texttt{discovery} view function for rendering supported devices to the page. Instead of using basic indexing, the string \texttt{join} method was used instead. The next task that needs to be completed is figuring out how to distinguish each devices each other with a unique id. The simple way of implementing this is by simpling using the entry
\begin{verbatim}
id INTEGER PRIMARY KEY AUTOINCREMENT
\end{verbatim}
which will increment the id value every time a new row is added to the database. An elegant way of indexing each device id is by using the loop.index variable available whenever at iterable object is iterated over in an html page. For example, the code
\begin{Verbatim}
{% for _ in range(3) %}
<h1>{{ loop.index }}</h1>
{% endfor %}
\end{Verbatim}
will write out the h1 headers 1,2,3. The loop.index variable can be placed as the value of an id attribute for each checkbox on the discovery page. Each id will correspond to the id of each device.
\smallbreak\noindent
An addition to the \texttt{discovery.js} file will be need to made which registers callback function for the "Search for devices" button whenever it is pressed with jQuery. The jQuery.ajax method will be used for sending an ajax request to the server to prevent the page from reloading when the submit is pressed. The code for the request is posted below:
\begin{Verbatim}[tabsize=4]
$(document).ready(function() {
  $("#find_devices").click( function(evt) {
    // Prevent the default behavior from occurring.
    evt.preventDefault();
    var ids = [];
    $("input[type=checkbox]:checked").each(function() {
      ids.push($(this).attr("id"));
    });
    jsonIDs = JSON.stringify(ids)
    // alert(jsonDevices);
    $.ajax({
      url: '/discovery/ajax',
      type: 'POST', // Send a POST request
      contentType: 'application/json;charset=UTF-8',
      data: jsonIDs,
      success: function(response) {
        console.log(response);
      }
    });
  });
});// $ here so the text after isn't green in the tex file
\end{Verbatim}
This function sends a json stringified list containing the ids of the devices to be discovered. A flask view function will be registered to the url \texttt{/discovery/ajax} which will publish the data found to the discovery agent. However, the problem I am having is that when the discovery agent is started with the \texttt{run.sh} script, the terminal hangs and the web server is not able to run. Therefore, I will need to figure how to get all the agents to run from one terminal. This is solved by using the \& operator in bash will spawn a new process for the agent to run.

\labday{Tuesday, May 26, 2020}
When I tried publishing a message to the discovery agent I got the following error:
\begin{Verbatim}
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/home/blauer/NewBEMS/WebServer/pubsub.py", line 7, in publish
    socket.send(f"{topic} {message}".encode('utf-8'))
  File "/home/blauer/.local/lib/python3.6/site-packages/zmq/sugar/socket.py", 
  line 400, in send
    return super(Socket, self).send(data, flags=flags, copy=copy, track=track)
  File "zmq/backend/cython/socket.pyx", line 728, 
  in zmq.backend.cython.socket.Socket.send
  File "zmq/backend/cython/socket.pyx", line 775, 
  in zmq.backend.cython.socket.Socket.send
  File "zmq/backend/cython/socket.pyx", line 247, 
  in zmq.backend.cython.socket._send_copy
  File "zmq/backend/cython/socket.pyx", line 242, 
  in zmq.backend.cython.socket._send_copy
  File "zmq/backend/cython/checkrc.pxd", line 26, 
  in zmq.backend.cython.checkrc._check_rc
zmq.error.ZMQError: Operation not supported
\end{Verbatim}
I discovered that the problem lied in the parameter passed to the \texttt{zmq.Context.socket} constructor which was set as zmq.SUB originally but needed to be changed to zmq.PUB. The corrected code is posted below in the file \texttt{/NewBEMS/WebServer/pubsub.py}:
\begin{Verbatim}
import zmq

def publish(topic, message, port):
    context = zmq.Context()
    socket = context.socket(zmq.PUB)
    socket.bind(f"tcp://*:{port}")
    socket.send(f"{topic} {message}".encode('utf-8'))
    socket.close()
    context.term()
\end{Verbatim}
A second problem I am having is when the function is called, the agent is not properly receiving the message. The problem only occurs when the code from the function above is run inside of a script but not when each line is run individually using the python interpreter.
\smallbreak\noindent
After some experimenting, I found that the message must be sent twice with a short delay (100 ms) in between in order for the message to be received by the subscriber (Discovery Agent). The message is not in fact received twice by the agent but only once by the second transmission. Therefore, the modified code is posted below:
\begin{Verbatim}
import zmq
import time

def publish(topic, method, args):
    context = zmq.Context()
    socket = context.socket(zmq.PUB)
    socket.bind("tcp://*:5556")
    # The message must be sent twice to the subscriber in
    # order for it to be properly received. Not totally sure
    # why this is, possibly just the way zmq was designed.
    for _ in range(2):
        socket.send(f"{topic} {method} {args}".encode('utf-8'))
        time.sleep(0.1)
    socket.close()
    context.term()
\end{Verbatim}
After further experimenting I found that 100 ms is too short, so it was increased to 1 s with guaranteed transmission.
\smallbreak\noindent
The next task to be completed is working on the \texttt{searchForDevices} method in the \texttt{DiscoveryAgent} class which will automatically import the corresponding API modules in the DeviceDrivers directory depending on the device to be discovered. Then each device will have a \texttt{findDevices} method which will search for devices on the network.

\labday{Thursday, May 28, 2020}
What needs to be done today is to do the following:
\begin{itemize}
\item Make the NewBEMS directory visible in the virtual environment (modify the PATH variable)
\item Create a new directory called \texttt{utils} in the NewBEMS directory that will contain some helper modules for database access, etc.
\item Add a text field to the supported devices table called API
\end{itemize}
Adding the NewBEMS (top level directory) to the path is as simple as adding the path

\labday{Monday, June 8, 2020}
Today, I worked on testing my DiscoveryAgent method for adding new entries to the 'ActiveDevices' table once they are discovered by the agent named \texttt{setDeviceToActive}. The code is posted below:
\begin{Verbatim}
    def setDeviceToActive(self, metadata):
        conn = sqlite3.connect('/home/blauer/NewBEMS/WebServer/meta.db')
        curs = conn.cursor()
        print('Executing cursor!')
        curs.execute("SELECT id FROM ActiveDevices WHERE name = ?;", 
        (metadata['name'],))
        result = curs.fetchall()
        print(result)
        if len(result) == 0:
            try:
                print('Adding device to active devices')
                curs.execute('INSERT INTO ActiveDevices 
                (name, manufacturer, macaddress) VALUES (?, ?, ?);',
                    (metadata['name'], metadata['manufacturer'], 
                    metadata['macaddress']))
            except Exception as e:
                print("Insertion into active devices failed")
        curs.close()
        conn.close()
\end{Verbatim}
The code inside is executing; however the SQL query to insert the device into the database is failing in some way as when I run the query 
\texttt{SELECT * FROM ActiveDevices;} in the command prompt for the database it doesn't return any values. However, after running the query:
\begin{Verbatim}
SELECT * FROM ActiveDevices; 
\end{Verbatim}
in the \texttt{setDeviceToActive} method and calling \texttt{curs.fetchall()} the database returned the correct values.

\end{addmargin}

\bibliographystyle{plain}
\bibliography{bib/seniorProject2017.bib}


% \begin{thebibliography}{9}

% \bibitem{lamport94}
% Leslie Lamport,
% \emph{\LaTeX: A Document Preparation System}.
% Addison Wesley, Massachusetts,
% 2nd Edition,
% 1994.

% \end{thebibliography}

%----------------------------------------------------------------------------------------

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End}